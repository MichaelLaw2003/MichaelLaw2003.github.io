<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/project/2024/01/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title> Notes on Stomatopod&#39;s visual ability: 1 </title>
    <url>/project/2024/01/28/Stomatopod&#39;s%20vision/Notes-on-Stomatopod-s-visual-ability-1/</url>
    <content><![CDATA[<h1 id="Notes-on-Stomatopod’s-visual-ability-1"><a href="#Notes-on-Stomatopod’s-visual-ability-1" class="headerlink" title="Notes on Stomatopod’s visual ability: 1"></a>Notes on Stomatopod’s visual ability: 1</h1><h2 id="Research-subject"><a href="#Research-subject" class="headerlink" title="Research subject"></a>Research subject</h2><p>The research subject is the Stomatopod, which is commonly known as the mantis shrimp.</p>
<p>The Stomatopods have the greatest diversity of color receptor types known for any animal, and have a diverse set of photoreceptors that visualize polarized light. The review will focus on the features of the Stomatopod’s ability to visualize color and polarized light .</p>
<p>In this field, the term “Stomatopod” is usually restricted to Gonodactyloidea and Lysiosquilloidea species.</p>
<p><em>Odontodactylus scyllarus</em>, a gonodactyloid stomatopod, is a commonly used model organism.</p>
<p><img src="/2024/01/28/Stomatopod's%20vision/Notes-on-Stomatopod-s-visual-ability-1/image1.jpg" alt="&quot;Odontodactylus havanensis&quot;"></p>
<p><em>Odontodactylus havanensis</em>, (Cronin, 2006) <em>Copyright © 2006 Elsevier Ltd. All rights reserved.</em>, License Number 5716910107274</p>
<h2 id="Morphological-description-of-the-compound-eye-of-Stomatopods"><a href="#Morphological-description-of-the-compound-eye-of-Stomatopods" class="headerlink" title="Morphological description of the compound eye of Stomatopods"></a>Morphological description of the compound eye of Stomatopods</h2><p>The apposition compound eyes of an <em>Odontodactylus scyllarus</em> is morphologically divided in to three parts, namely (a) the dorsal hemisphere, (b) the <strong>midband</strong>, and (c) the ventral hemisphere. The basic units of vision of the compound eye is termed as “<strong>ommatidia</strong>“.</p>
<p>The midband has 6 rows of ommatidia with bigger cornea compared with other ommatidia. This suggest that the midband and hemispherical ommatidia have different function. The dorsal hemisphere and a ventral hemisphere is spatially divided up by the midband.(Marshall, 1988)</p>
<p>(The compond eye of <em>Lysiosquilla tredecimdentata</em> has larger dorsal and ventral hemispheres, but still has the midband consisting of 6 rows of ommatidia. The compond eye of Oratosquilla solicitans*, from another superfamily, only has 2 midbands.) (Marshall et al., 2007)</p>
<p><img src="/2024/01/28/Stomatopod's%20vision/Notes-on-Stomatopod-s-visual-ability-1/image2.png" alt="Eye"></p>
<p>Eye of <em>Odontodactylus scyllarus</em>, (a) Frontal view, Scale 500 mm. (b) Dorsal view, showing the dorsal hemisphere and eye stalk. Scale 500 mm. (c) Sagittal section through <em>O. scyllarus</em> eye. From right to left: cornea, crystalline cones, distal retinal pigment (white line), retina (black crescent), and the first optic neuropil, the lamina ganglionaris (white region). Scale 400 mm. (Marshall et al., 2007) <em>Copyright © 1988, Springer Nature Limited</em></p>
<h2 id="General-anatomical-description-of-the-ommatidia-of-Stomatopods"><a href="#General-anatomical-description-of-the-ommatidia-of-Stomatopods" class="headerlink" title="General anatomical description of the ommatidia of Stomatopods"></a>General anatomical description of the ommatidia of Stomatopods</h2><p>The 6 rows of the midband ommatidia are structurally different from one another. There are 16 anatomically different photoreceptors in the compond eye of Stomatopod.</p>
<p>A ommatidium, from the distal end to the proximal end, roughly consists of 4 main parts, namely (a) cornea(lenses), (b) crystalline cones, (c) distal pigment, (d) rhabdom and sensory cells. At the proximal end, the ommatidia are connected to the nerve fiber by axons. (Marshall, 1988)</p>
<p><img src="/2024/01/28/Stomatopod's%20vision/Notes-on-Stomatopod-s-visual-ability-1/image3.png" alt="ommatidia"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Cronin, T. W. (2006). Stomatopods. <em>Current Biology</em>, <em>16</em>(7), R235-R236. <a href="https://doi.org/10.1016/j.cub.2006.03.014">https://doi.org/10.1016/j.cub.2006.03.014</a></p>
<p>Marshall, J., Cronin, T. W., &amp; Kleinlogel, S. (2007). Stomatopod eye structure and function: a review. <em>Arthropod Struct Dev</em>, <em>36</em>(4), 420-448. <a href="https://doi.org/10.1016/j.asd.2007.01.006">https://doi.org/10.1016/j.asd.2007.01.006</a></p>
<p>Marshall, N. J. (1988). A Unique Color and Polarization Vision System in Mantis Shrimps. <em>Nature</em>, <em>333</em>(6173), 557-560. <a href="https://doi.org/DOI">https://doi.org/DOI</a> 10.1038&#x2F;333557a0</p>
]]></content>
      <categories>
        <category>neuroscience</category>
      </categories>
      <tags>
        <tag>mantis shrimp</tag>
        <tag>vision</tag>
        <tag>neuroscience</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Biochemistry terms in Rosetta</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/Biochemistry%20Terms/</url>
    <content><![CDATA[<h2 id="Amino-Acids-table"><a href="#Amino-Acids-table" class="headerlink" title="Amino Acids table"></a>Amino Acids table</h2><p>![](Biochemistry Terms.assets&#x2F;1756448806829-c0b0ec2d-e68b-42b3-beae-8f01b8f3befa.png)</p>
<p>![](Biochemistry Terms.assets&#x2F;1756457007528-dfa3cb12-1a67-4220-bae3-5618147d4bd9.png)</p>
<p>*NOTICE: Selenocysteine is not a component of natural proteins.</p>
<h2 id="Atom-name-definition"><a href="#Atom-name-definition" class="headerlink" title="Atom name definition"></a>Atom name definition</h2><p>Starting from nitrogen in $ -NH_2 $ group (defined as “N”) in the backbone, the carbon atom connected to it, that is, the central carbon, is defined as “$ C_\alpha $” or “CA”, and the adjacent carbon in $ -COOH $ group in the backbone is defined as “C”. Other carbon atoms, accroding to their distances to $ C_\alpha $, are correspondingly defined as $ C_{\beta} $(CB), $ C_{\gamma} $(CG), $ C_{\delta} $(CD), $ C_{\epsilon} $(CE), $ C_{\zeta} $(CZ), $ C_{\eta} $(CH).</p>
<h2 id="Ramachandran-dihedrals"><a href="#Ramachandran-dihedrals" class="headerlink" title="Ramachandran dihedrals"></a><strong>Ramachandran dihedrals</strong></h2><p>The two torsion angles of the polypeptide chain, also called <strong>Ramachandran angles</strong>, describe the rotations of the polypeptide backbone around the bonds between:</p>
<ol>
<li>N-Cα (angle between $ C_{i-1} $ and $ C_i $, denoted Phi, φ) and </li>
<li>Cα-C (angle between $ N_i $and $ N_{i+1} $, called Psi, ψ) </li>
<li>C-N (peptide bond, angle between $ C_{\alpha \ i-1} $and $ C_{\alpha \ i} $, denoted Omega, $ \omega $)</li>
</ol>
<h3 id="Biochemistry-Terms-assets-1754906512373-ccbd22a8-3030-4ba9-9ff1-2170831fcbb6-jpeg"><a href="#Biochemistry-Terms-assets-1754906512373-ccbd22a8-3030-4ba9-9ff1-2170831fcbb6-jpeg" class="headerlink" title="![](Biochemistry Terms.assets&#x2F;1754906512373-ccbd22a8-3030-4ba9-9ff1-2170831fcbb6.jpeg)"></a>![](Biochemistry Terms.assets&#x2F;1754906512373-ccbd22a8-3030-4ba9-9ff1-2170831fcbb6.jpeg)</h3><p>![](Biochemistry Terms.assets&#x2F;1754891261167-472a5b30-b731-4c1d-9750-8d2a36f46a44.png)</p>
<p>In most cases, $ \omega $&#x3D; 180°. </p>
<p>In very rare cases, $ \omega $&#x3D; 0° (Not energetically favorable.)</p>
<p>![](Biochemistry Terms.assets&#x2F;1754973177592-8e40a126-d1a5-415b-bb53-8da85d008415.png)</p>
<p>![](Biochemistry Terms.assets&#x2F;1754982392808-f76bc423-469c-4dbf-96b3-146d8a1e761c.png)</p>
<p>phi &#x3D; −64.8°, psi &#x3D; -41.0° for left handed α-helix, </p>
<p>phi &#x3D; -135.0°, psi &#x3D; 135.0° for beta-strand, </p>
<p>and around phi &#x3D; 60°, psi &#x3D; 40° for L-helix</p>
<p>Ramachandran angles in Rosetta： <a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/movers_pages/MakeBundleMover">https://docs.rosettacommons.org/docs/latest/scripting_documentation&#x2F;RosettaScripts&#x2F;Movers&#x2F;movers_pages&#x2F;MakeBundleMover</a></p>
<p><code>alter 1-10/, ss=&#39;H&#39;</code>Set No.1 - No.10 amino acids to “alpha-helix” style in PyMOL </p>
<h2 id="Side-chain-dihedrals"><a href="#Side-chain-dihedrals" class="headerlink" title="Side-chain dihedrals"></a>Side-chain dihedrals</h2><p>![](Biochemistry Terms.assets&#x2F;1754973218787-55dd3aa0-9739-4689-ab32-ab46f5b392ca.png)</p>
<h2 id="Hydrogen-and-disulfide-bonds"><a href="#Hydrogen-and-disulfide-bonds" class="headerlink" title="Hydrogen and disulfide bonds"></a>Hydrogen and disulfide bonds</h2><p>![](Biochemistry Terms.assets&#x2F;1754973265835-93ed4e94-4407-40d7-82e8-59047cf2a02b.png)</p>
<h2 id="Ambiguous-Hydrogen"><a href="#Ambiguous-Hydrogen" class="headerlink" title="Ambiguous Hydrogen"></a>Ambiguous Hydrogen</h2><p>For certain amino acids, the position of a hydrogen atom can be ambiguous due to the symmetry of the sidechain or because the sidechain can adopt different rotamers. </p>
<h2 id="α-helix-3-6-13-helix"><a href="#α-helix-3-6-13-helix" class="headerlink" title="α-helix (3.6&#x2F;13-helix)"></a>α-helix (3.6&#x2F;13-helix)</h2><p>螺旋周期约为3.6个氨基酸残基，即每3.6个残基螺旋上升一圈，</p>
<p>Spiral period is 3.6 residues, that is, the spiral rises a turn every 3.6 residues</p>
<p>Average atoms per turn: 13</p>
<p>Pitch: ~ 5.4 Å</p>
<p>Rise per residue: ~ 1.5  Å</p>
<p>![](Biochemistry Terms.assets&#x2F;1756435907598-6470fa11-abb6-44da-9d1b-ddd33901a430.png)</p>
<p>![](Biochemistry Terms.assets&#x2F;1756439552780-1d7e62a4-703e-4cb1-aeaa-a5031dbe8644.png)</p>
<p>The [Peptide bond surfaces] are approximately parallel to the central axis of the helix, and the common direction of all the peptide bonds makes the whole α-helix a macro dipole, with the N-terminus ~ + 0.5 e and the C terminus ~ - 0.5 e.</p>
<h3 id="Crick-equation-for-α-helix"><a href="#Crick-equation-for-α-helix" class="headerlink" title="Crick equation for α-helix"></a>Crick equation for α-helix</h3><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>Crick equation describes the geometry of one helix of helices (one helix in a super helix).</p>
<h4 id="Major-Parameters"><a href="#Major-Parameters" class="headerlink" title="Major Parameters"></a>Major Parameters</h4><ol>
<li><p>**The super-helical radius (R0)**：the “major super halical radius”; the distances between helices, depending on the number of helices, ~3-10 Å</p>
</li>
<li><p><strong>The super helical frequency (ω0)</strong>: super-helix torsion; helix twists (curve) around Z axis; measured by “how each a.a. contribute to the curvature of a helix”, -2.5~2.5°(plus or minus determines the chirality)</p>
</li>
<li><p><strong>Helical phase offset (Δφ1) of a helix</strong>: the angle that the helix turns around its own central axis, relative to the initial helical phase (φ1), Δφ1 &#x3D; ω1·t </p>
<p>NOTICE: This is delta_omega1 in Rosetta.</p>
</li>
<li><p><strong>Super-helical phase offset (Δφ0) of a helix</strong>: the angle that the helix turns around the central axis of the super helix (the Z axis), relative to the initial super-helical phase (φ0), Δφ0 &#x3D; ω0·t NOTICE: This is <strong>delta_omega0</strong> in Rosetta</p>
</li>
<li><p><strong>Chain axial offset (ΔZ) of a helix</strong>: the distance that a helix moves along the central Z axis of the super-helix</p>
</li>
<li><p><strong>The helical radius (R1)</strong>: α-helix radius, usually set to the ideal value of an α-helix</p>
</li>
<li><p><strong>The helical frequency (ω1)</strong>: α-helix curvature, coupled to  ω0, for an ideal  α-helix, ω0+ω1&#x3D;100°</p>
</li>
</ol>
<h4 id="The-equation"><a href="#The-equation" class="headerlink" title="The equation"></a>The equation</h4><p>![](Biochemistry Terms.assets&#x2F;1756437767710-5f26396a-ee38-4e50-bd94-9327b2cb1eb1.png)</p>
<h3 id="Parameters-in-Rosetta"><a href="#Parameters-in-Rosetta" class="headerlink" title="Parameters in Rosetta"></a>Parameters in Rosetta</h3><p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/movers_pages/MakeBundleMover">MakeBundle</a></p>
<h2 id="3-10-helix"><a href="#3-10-helix" class="headerlink" title="3&#x2F;10-helix"></a>3&#x2F;10-helix</h2><p>Not discussed here</p>
<h2 id="π-helix"><a href="#π-helix" class="headerlink" title="π-helix"></a>π-helix</h2><p>Not discussed here</p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes on Stomatopod&#39;s visual ability: 2</title>
    <url>/project/2024/02/03/Stomatopod&#39;s%20vision/Notes-on-Stomatopod-s-visual-ability-2/</url>
    <content><![CDATA[<h1 id="Notes-on-Stomatopod’s-visual-ability-2"><a href="#Notes-on-Stomatopod’s-visual-ability-2" class="headerlink" title="Notes on Stomatopod’s visual ability: 2"></a>Notes on Stomatopod’s visual ability: 2</h1><h2 id="Terms-and-abbreviations"><a href="#Terms-and-abbreviations" class="headerlink" title="Terms and abbreviations"></a>Terms and abbreviations</h2><table>
<thead>
<tr>
<th>Abbreviation</th>
<th>Term</th>
<th>Description</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>MO[x]</td>
<td>mid-band ommatidia(中带复眼)</td>
<td>Basic units of a mid-band.</td>
<td>There are 6 <strong>rows</strong> of midband eyes, designated as MO[1-6]. Each ommatidium in MO[1-4] has 3 tiers of rhabdom. Each ommatidium in MO[5,6] has 2 tiers of rhabdom. A  hemispherical ommatidium has 2 tiers of rhabdom.</td>
</tr>
<tr>
<td>R[x]</td>
<td>Rhabdomeres(感杆）</td>
<td>The elongated rod-like portion of the retinular cells, the subunit of the  rhabdom, containing closely spaced and longitudinal rows of microvilli and  pigment granules.</td>
<td>There are 8 <strong>types</strong> of rhabdomeres, designated as R[1-8]. R8  cells consist the most distal tier of rhabdom in all types (midband and  hemispherical) of ommatidium.</td>
</tr>
<tr>
<td>DR[x]</td>
<td>Distally placed rhabdomeres（远端感杆）</td>
<td>Rhabdomeres that consist the distally placed rhabdom in <strong>MO[1-4]</strong>, which is  placed between the R[8] rhabdom and the PR rhabdom.</td>
<td>There are 7 <strong>types</strong> of DR, which are  R[1-7]. They are specially designated as DR[1-7].</td>
</tr>
<tr>
<td>PR[x]</td>
<td>Proximal placed rhabdomeres（近端感杆）</td>
<td>Rhabdomeres that consist the proximally placed rhabdom in <strong>MO[1-4]</strong>, which  is placed at the proximal end, that is, close to the basement menbrane.</td>
<td>There are 7 <strong>types</strong> of PR,  which are R[1-7]. They are specially  designated as PR[1-7].</td>
</tr>
<tr>
<td>F[x]</td>
<td>Filter（滤光体）</td>
<td>Specialized, coloured intra-rhabdomal structures in <strong>MO[2,3]</strong>, function as  the filter of light in a specific wavelength band.</td>
<td>There are 2 <strong>layers</strong> of filters, designated as F[1], F[2]. F[1] is relatively distal and F[2] is relatively proximal.</td>
</tr>
</tbody></table>
<h2 id="General-structures-of-hemispherical-ommatidia"><a href="#General-structures-of-hemispherical-ommatidia" class="headerlink" title="General structures of hemispherical ommatidia"></a>General structures of hemispherical ommatidia</h2><p><img src="/2024/02/03/Stomatopod's%20vision/Notes-on-Stomatopod-s-visual-ability-2/ommatidia1.svg" alt="Structure of hemispherical ommatidia"></p>
<h2 id="General-structures-of-mid-band-ommatidia"><a href="#General-structures-of-mid-band-ommatidia" class="headerlink" title="General structures of  mid-band ommatidia"></a>General structures of  mid-band ommatidia</h2><h3 id="General-Structure-of-MO-1-4"><a href="#General-Structure-of-MO-1-4" class="headerlink" title="General Structure of MO[1-4]"></a>General Structure of MO[1-4]</h3><p>![midband ommatidia](Notes-on-Stomatopod-s-visual-ability-2&#x2F;midband ommatidia.svg)</p>
<h3 id="Special-structures-of-MO-2-3-Filters"><a href="#Special-structures-of-MO-2-3-Filters" class="headerlink" title="Special structures of MO[2,3] - Filters"></a>Special structures of MO[2,3] - Filters</h3><p><img src="/2024/02/03/Stomatopod's%20vision/Notes-on-Stomatopod-s-visual-ability-2/filters.svg" alt="filters"></p>
<h3 id="General-Structure-of-MO-5-6"><a href="#General-Structure-of-MO-5-6" class="headerlink" title="General Structure of MO[5,6]"></a>General Structure of MO[5,6]</h3><p>The General structure of MO[5,6] is similar to that of hemispherical ommatidia. However, the arrangement of microvillar in MO[5,6] are modified.</p>
<ul>
<li>Very thin layering with precise orthogonal arrangements in R[1-7];</li>
<li>Unidirectionally arranged microvili in R[8];</li>
<li>Elongated R[8] rhabdomere;</li>
<li>A secondary orthogonality of the microvilli between MO[5,6].</li>
</ul>
]]></content>
      <categories>
        <category>neuroscience</category>
      </categories>
      <tags>
        <tag>mantis shrimp</tag>
        <tag>vision</tag>
        <tag>neuroscience</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes on Stomatopod&#39;s visual ability 3</title>
    <url>/project/2024/02/16/Stomatopod&#39;s%20vision/Notes-on-Stomatopod-s-visual-ability-3/</url>
    <content><![CDATA[<h1 id="Notes-on-Stomatopod’s-visual-ability-3"><a href="#Notes-on-Stomatopod’s-visual-ability-3" class="headerlink" title="Notes on Stomatopod’s visual ability: 3"></a>Notes on Stomatopod’s visual ability: 3</h1><h2 id="Summary-of-the-structure-of-Stomatopod’s-eye"><a href="#Summary-of-the-structure-of-Stomatopod’s-eye" class="headerlink" title="Summary of the structure of Stomatopod’s eye"></a>Summary of the structure of Stomatopod’s eye</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>The compound eye of a Stomatopod is a hemispherical structure connected to an eye stalk.</p>
<p>The compound eye consists of many ommatidia.</p>
<p>Each ommatidia is mainly consists of</p>
<ul>
<li><p>a cornea (facet) on the surface,</p>
</li>
<li><p>a crystalline cone underneath the cornea,</p>
</li>
<li><p>distal pigment cells surrounding the crystalline cones,</p>
</li>
<li><p>retinular cells (photoreceptor cells) underneath the crystalline cone.</p>
</li>
</ul>
<p>(Assume that the distal - proximal axis of an ommatidia is vertical, as is illustrated in <a href="https://michaellaw2003.github.io/2024/02/03/Notes-on-Stomatopod-s-visual-ability-2/">Notes on Stomatopod’s visual ability: 2</a> .)</p>
<p>6 rows of special ommatidia divides the hemispherical compound eye into two parts, namely dorsal and ventral hemispheres (DH &amp; VH).</p>
<p>These 6 rows of special ommatidia has larger cornea (facet), and are termed as mid-band ommatidia, designated as MO[1-6].</p>
<p>The cell membranes of retinular cells extend and form rhabdomeres, and the rhabdomeres form a bundle structure termed rhabdom. The rhabdom functions as a light guide.</p>
<p>The retinular cells are simply described as “rhabdom” in some documents.</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>There are 8 retinular cells in an ommatidia, whose shape and location are different to each other, designated as R[1-8].</p>
<p>DH &amp; VH retinular cells are divided into two layers (based on the shape of the cross section imaging), namely distal end layer and proximal end layer. All the 8 retinular cells in an ommatidia are present at each layer (tier) .</p>
<p>The distal end layer mainly consists of a single R[8] cell. The proximal end layer consists of R[1-7] cells, which form a flower-like ring structure, with the rhabdomeres at the center of the ring.</p>
<p>The retinular cells of MO[1-4] are three layered, with a distal end layer similar to that of DH &amp; VH ommatidia, but the proximal end layer are divided into two sub-layers.</p>
<p>All the R[1-7] cells are present in the two sub-layers at the proximal end. In MO[1,3,4], the R[1,4,5] cells are above the R[2,3,6,7], while in MO[2], the R[2,3,6,7] cells are above the R[1,4,5] cells.</p>
<p>All the R[1-8] cells construct the retinula with both small distal projections (microvilli) in the rhabdom, and the axons connected to the optic nerve centers.</p>
<p>The retinula of all the ommatidia consist retina.</p>
<h2 id="Notes-on-connectivity-of-optic-neuropils"><a href="#Notes-on-connectivity-of-optic-neuropils" class="headerlink" title="Notes on connectivity of optic neuropils"></a>Notes on connectivity of optic neuropils</h2><p><strong>Lamina ganglionaris</strong> (lamina) and <strong>medulla externa</strong> (ME), <strong>medulla interna</strong>(MI), <strong>medulla terminalis</strong>(NT) in the eye rod are optic neuropils in Stomatopods.(Marshall et al., 2007)</p>
<p>All optic neuropils have <strong>subdivisions</strong> reflecting subdivisions of the retina - DH, midband, VH.(Marshall et al., 2007)</p>
<p>The axons of the photorecepters project to the lamina, forming synapses with lamina monopolar cells LMCs.(This conclusion is from a paper introducing butterfly, and thus may be inaccurate for mantis shrimps.) (Matsushita et al., 2022)</p>
<p>On the way from basement membrane to the lamina, axons form <strong>fasicles</strong>, in which the arrangement of the axons twists 180°. The collection of axons and <strong>LMCs</strong> consists of a structure termed as the <strong>cartridge</strong>.(Marshall et al., 2007)</p>
<p>In the image of the section at the level of the lamina, the lamina cartridge of MO[5,6] are ovoid in shape, the MO[1-4] rectangular, and DH&#x2F;VH hexagonal.(Marshall et al., 2007)</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>Marshall, J., Cronin, T. W., &amp; Kleinlogel, S. (2007). Stomatopod eye structure and function: a review. <em>Arthropod Struct Dev</em>, <em>36</em>(4), 420-448. <a href="https://doi.org/10.1016/j.asd.2007.01.006">https://doi.org/10.1016/j.asd.2007.01.006</a></p>
<p>Matsushita, A., Stewart, F., Ilić, M., Chen, P.-J., Wakita, D., Miyazaki, N., Murata, K., Kinoshita, M., Belušič, G., &amp; Arikawa, K. (2022). Connectome of the lamina reveals the circuit for early color processing in the visual pathway of a butterfly. <em>Current Biology</em>, <em>32</em>(10), 2291-2299.e2293. <a href="https://doi.org/10.1016/j.cub.2022.03.066">https://doi.org/10.1016/j.cub.2022.03.066</a> (Current Biology)</p>
]]></content>
      <categories>
        <category>neuroscience</category>
      </categories>
      <tags>
        <tag>mantis shrimp</tag>
        <tag>vision</tag>
        <tag>neuroscience</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Customize Mover</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/Customize%20Mover/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a SequenceMover to chain the protocols together.</span></span><br><span class="line"><span class="comment"># Note: For real applications, you might need a TaskOperation to</span></span><br><span class="line"><span class="comment"># constrain residues from HBNet during the relax step.</span></span><br><span class="line">protocol = rosetta.protocols.moves.SequenceMover()</span><br><span class="line">protocol.add_mover(hbnet_mover)</span><br><span class="line">protocol.add_mover(fast_relax_mover)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>FoldTree Terms</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/FoldTree%20Terms/</url>
    <content><![CDATA[<h1 id="FoldTree-Terms"><a href="#FoldTree-Terms" class="headerlink" title="FoldTree Terms"></a><code>FoldTree</code> Terms</h1><h2 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h2><p>In Rosetta, a Jump represents a rigid-body transformation between two parts of a molecular system, like two protein chains, a protein and a ligand, or two disconnected sections of the same chain. This concept is tied to the FoldTree, which describes the kinematic relationships between residues in a Pose. </p>
<p>A Jump is a single degree of freedom in the kinematic tree. Instead of a series of single-bond torsions, a Jump consists of six degrees of freedom: three for rotation and three for translation. This allows for the movement of entire rigid bodies relative to one another. </p>
<p>Common scenarios where<code>Jumps</code> are used include:</p>
<ul>
<li><strong>Protein-protein interfaces</strong>: Each chain in a multi-chain <code>Pose</code> is typically treated as a rigid body, with <code>Jumps</code>connecting the chains.</li>
<li><strong>Protein-ligand complexes</strong>: The ligand is treated as a separate rigid body connected to the protein by a<code>Jump</code>.</li>
<li><strong>Modeling loops</strong>: By introducing a virtual <code>Jump</code> and a “chain break”, Rosetta can effectively sample the conformational space of a protein loop while keeping the rest of the protein fixed.</li>
</ul>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (1) Pose</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(1)%20Pose/</url>
    <content><![CDATA[<h1 id="PyRosetta-1-Pose"><a href="#PyRosetta-1-Pose" class="headerlink" title="PyRosetta (1): Pose"></a>PyRosetta (1): Pose</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line">init()</span><br><span class="line"><span class="comment">#import pyrosetta</span></span><br><span class="line"><span class="comment">#pyrosetta.init()</span></span><br></pre></td></tr></table></figure>

<h2 id="Poseclass"><a href="#Poseclass" class="headerlink" title="Poseclass"></a><code>Pose</code>class</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li>Simplified explanation: <ol>
<li><code>Pose</code>(<code>pyrosetta.Pose</code>) is defined as a Python class</li>
<li><code>Pose</code>is the core concept of PyRosetta</li>
<li>An instance of the<code>Pose</code>class is refered to as a “pose object”.</li>
<li>A pose object is a protein structure.</li>
</ol>
</li>
<li>Further explanation:<ol>
<li>A pose object may also include informations about related ions, ligand and other molecules.</li>
<li>A pose object may have more than one protein chains (quaternary protein, or protein complex)</li>
<li>Like any other Python classes, the<code>Pose</code>class has methods and attributes.</li>
<li>Class methods can be visited from the instances of the class.</li>
</ol>
</li>
</ol>
<h3 id="Pose-instantiation"><a href="#Pose-instantiation" class="headerlink" title="Pose instantiation"></a><code>Pose</code> instantiation</h3><h4 id="Initiate-an-instance-of-Pose-from-a-PDB-file"><a href="#Initiate-an-instance-of-Pose-from-a-PDB-file" class="headerlink" title="Initiate an instance of Pose from a PDB file"></a>Initiate an instance of <code>Pose</code> from a PDB file</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose_1 = pose_from_pdb(<span class="string">&quot;./path_to_pdb/5tj3.pdb&quot;</span>) </span><br><span class="line"><span class="comment"># pyrosetta.pose_from_pdb</span></span><br><span class="line"><span class="comment"># load &#x27;5tj3.pdb&#x27; from file</span></span><br></pre></td></tr></table></figure>

<p>Or,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose_1 = pyrosetta.io.pose_from_file(filename=<span class="string">&quot;./path_to_pdb/5tj3.pdb&quot;</span>)</span><br><span class="line"><span class="comment"># load &#x27;5tj3.pdb&#x27; from file</span></span><br></pre></td></tr></table></figure>

<h4 id="Initiate-an-instance-of-Pose-from-https-www-rcsb-org"><a href="#Initiate-an-instance-of-Pose-from-https-www-rcsb-org" class="headerlink" title="Initiate an instance of Pose from https://www.rcsb.org/"></a>Initiate an instance of <code>Pose</code> from <a href="https://www.rcsb.org/">https://www.rcsb.org/</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose_2 = pose_from_rcsb(<span class="string">&quot;5TJ3&quot;</span>)</span><br><span class="line"><span class="comment"># pyrosetta.toolbox.rcsb.pose_from_rcsb</span></span><br><span class="line"><span class="comment"># load 5TJ3 from online database</span></span><br></pre></td></tr></table></figure>

<h4 id="Initiate-an-instance-of-Posefrom-a-string-a-sequence"><a href="#Initiate-an-instance-of-Posefrom-a-string-a-sequence" class="headerlink" title="Initiate an instance of Posefrom a string (a sequence)"></a>Initiate an instance of <code>Pose</code>from a string (a sequence)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose_3 = pose_from_sequence(<span class="string">&quot;AAAAAAAAAA&quot;</span>)</span><br><span class="line"><span class="comment"># pyrosetta.pose_from_sequence</span></span><br><span class="line"><span class="comment"># load a &quot;poly alanine sequence&quot; from string</span></span><br></pre></td></tr></table></figure>

<h4 id="Initiate-an-empty-instance-of-Pose-And-create-a-clone-of-a-pose-object"><a href="#Initiate-an-empty-instance-of-Pose-And-create-a-clone-of-a-pose-object" class="headerlink" title="Initiate an empty instance of Pose (And create a clone of a pose object)"></a>Initiate an empty instance of <code>Pose</code> (And create a clone of a <code>pose</code> object)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose_4 = Pose() <span class="comment"># Now pose_4 is empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># we can now use pose_4 to create a deep clone (copy) of pose_1</span></span><br><span class="line">pose_4.assign(pose_1)</span><br></pre></td></tr></table></figure>

<h3 id="Pose-methods"><a href="#Pose-methods" class="headerlink" title="Pose methods"></a><code>Pose </code>methods</h3><h4 id="Copy-a-pose-object-via-Pose-assign"><a href="#Copy-a-pose-object-via-Pose-assign" class="headerlink" title="Copy a pose object via Pose.assign"></a>Copy a <code>pose</code> object via <code>Pose.assign</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a Pose instance called `my_pose`</span></span><br><span class="line">my_pose_clone = Pose() <span class="comment"># Now my_pose_clone is empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create a deep clone (copy) of my_pose</span></span><br><span class="line">my_pose_clone.assign(my_pose)</span><br></pre></td></tr></table></figure>

<p>WARNING: Avoid writing something like:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose_clone = my_pose </span><br><span class="line"><span class="comment"># This is incorrect</span></span><br></pre></td></tr></table></figure>

<p>Because in this way, my_pose_clone is pointed to value of my_pose, and modification to my_pose_clone will change my_pose.</p>
<h4 id="Copy-a-pose-object-via-Pose-clone"><a href="#Copy-a-pose-object-via-Pose-clone" class="headerlink" title="Copy a pose object via Pose.clone"></a>Copy a <code>pose</code> object via <code>Pose.clone</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assume that we have a `pose` object called `my_pose`</span></span><br><span class="line">my_pose_clone = my_pose.clone()</span><br></pre></td></tr></table></figure>

<h4 id="Get-sequence"><a href="#Get-sequence" class="headerlink" title="Get sequence"></a>Get sequence</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `my_pose` is an instance of Pose</span></span><br><span class="line">my_seq = my_pose.sequence()</span><br><span class="line"><span class="comment"># `my_seq` is a string, storing the sequence of my_pose</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-annotated-sequence"><a href="#Get-annotated-sequence" class="headerlink" title="Get annotated sequence"></a>Get annotated sequence</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_seq_annotated = my_pose.annotated_sequence()</span><br><span class="line"><span class="comment"># `my_seq` is a string, storing the annotated sequence of my_pose</span></span><br><span class="line"><span class="comment"># annotations are like: &#x27;...T[THR:phosphorylated]...&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-total-residue-count"><a href="#Get-total-residue-count" class="headerlink" title="Get total residue count"></a>Get total residue count</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_total_residue_count = my_pose.total_residue()</span><br><span class="line"><span class="comment"># `my_total_residue_count` is an integer</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-dihedral-angles"><a href="#Get-dihedral-angles" class="headerlink" title="Get dihedral angles"></a>Get dihedral angles</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `residue_id` is the ID (in pose) of a residue, type is integer</span></span><br><span class="line">my_pose.phi(residue_id) <span class="comment"># C-CaN-C dihedral</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; −64.8</span></span><br><span class="line">my_pose.psi(residue_id) <span class="comment"># N-CaC-N dihedral</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; -41.0</span></span><br><span class="line">my_pose.chi(<span class="number">1</span>, residue_id) <span class="comment"># 1st C-C dihedral in side chain</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; -82.8</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-an-Energies-object"><a href="#Get-an-Energies-object" class="headerlink" title="Get an Energies object"></a>Get an <code>Energies</code> object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_energies = my_pose.energies()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_energies.show(<span class="number">24</span>)) <span class="comment"># Print all energies terms (unweighted) of residue 24</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-a-Residue-object-by-its-position"><a href="#Get-a-Residue-object-by-its-position" class="headerlink" title="Get a Residue object by its position"></a>Get a <code>Residue</code> object by its position</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_20th = my_pose.residue(<span class="number">20</span>)</span><br><span class="line"><span class="comment"># `residue_20th` is an object that stores the 20th residue of `my_pose`</span></span><br></pre></td></tr></table></figure>

<p>Or,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_20th = my_pose.aa(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>Or,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_20th = relaxPose.sequence()[<span class="number">19</span>]</span><br></pre></td></tr></table></figure>

<p>See “Residue objects” in this note </p>
<p>WARNING: “the 20th residue in pose” is not equal to “the 20th residue in PDB”, because a pdb file may contain more than one chain.</p>
<h4 id="Get-a-PdbInfo-object"><a href="#Get-a-PdbInfo-object" class="headerlink" title="Get a PdbInfo object"></a>Get a <code>PdbInfo</code> object</h4><p>This object is a bridge between a <code>Pose</code> object and a PDB file:</p>
<ol>
<li>This object stores information from the original PDB file (if the pose is from a pdb file or from the pdb database).</li>
<li>Or, this object stores information that can be written into a PDB file.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pdb_info = my_pose.pdb_info()</span><br></pre></td></tr></table></figure>

<p>See “PdbInfo objects” in this note </p>
<h4 id="Get-a-Conformation-object"><a href="#Get-a-Conformation-object" class="headerlink" title="Get a Conformation object"></a>Get a <code>Conformation</code> object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_conformation = my_pose.conformation() <span class="comment"># Get conformation object</span></span><br></pre></td></tr></table></figure>

<h4 id="Get-a-FoldTree-object"><a href="#Get-a-FoldTree-object" class="headerlink" title="Get a FoldTree object"></a>Get a <code>FoldTree</code> object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tree = my_pose.fold_tree()</span><br><span class="line"><span class="built_in">print</span>(my_tree)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; FOLD_TREE  EDGE 1 107 -1  EDGE 1 108 1  EDGE 108 194 -1 </span></span><br></pre></td></tr></table></figure>

<p>The fundamental docking move is a rigid-body transformation consisting of a translation and rotation. Any rigid body move also needs to know which part moves and which part is fixed. In Rosetta, this division is known as a <code>Jump</code> and the set of protein segments and jumps are stored in an object attached to a pose called a <code>FoldTree</code>.</p>
<p>In the <code>FoldTree</code> printout, each three number sequence following the word <code>EDGE</code> is the beginning and ending residue number, then a code. The codes are -1 for stretches of protein and any positive integer for a <code>Jump</code>, which represents the <code>Jump</code> number.</p>
<h4 id="Get-a-Jump-class-by-its-ID"><a href="#Get-a-Jump-class-by-its-ID" class="headerlink" title="Get a Jump class by its ID"></a>Get a <code>Jump</code> class by its ID</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jump_num = <span class="number">1</span> <span class="comment"># the first jump</span></span><br><span class="line"><span class="built_in">print</span>(pose.jump(jump_num).get_rotation()) <span class="comment"># show the rotation matrix</span></span><br><span class="line"><span class="built_in">print</span>(pose.jump(jump_num).get_translation()) <span class="comment"># show the translation vector</span></span><br></pre></td></tr></table></figure>

<h4 id="Set-dihedral-angles-a-basic-mover"><a href="#Set-dihedral-angles-a-basic-mover" class="headerlink" title="Set dihedral angles (a basic mover)"></a>Set dihedral angles (a basic mover)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose.set_phi(<span class="number">24</span>, -<span class="number">64.8</span>) <span class="comment"># set phi of residue #24 to -64.8</span></span><br><span class="line">my_pose.set_psi(<span class="number">24</span>, -<span class="number">41.0</span>) <span class="comment"># set psi of residue #24 to -41.0</span></span><br></pre></td></tr></table></figure>

<h4 id="Set-foldtree-requires-a-pre-defined-FoldTree-object"><a href="#Set-foldtree-requires-a-pre-defined-FoldTree-object" class="headerlink" title="Set foldtree (requires a pre-defined FoldTree object)"></a>Set foldtree (requires a pre-defined <code>FoldTree</code> object)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `FoldTree` object called `my_ft`</span></span><br><span class="line">my_pose.fold_tree(my_ft)</span><br></pre></td></tr></table></figure>

<h4 id="Output-Save-a-pose-as-a-PDB-file"><a href="#Output-Save-a-pose-as-a-PDB-file" class="headerlink" title="Output (Save) a pose as a PDB file"></a>Output (Save) a pose as a PDB file</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose.dump_pdb(<span class="string">&#x27;/outputs/my_pose_arxiv.pdb&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Residue-class"><a href="#Residue-class" class="headerlink" title="Residue class"></a><code>Residue</code> class</h2><p><code>Residue</code>is a secondary class of <code>Pose</code>.</p>
<p>A <code>residue</code>object stores information about a residue.</p>
<p>NOTICE: An ion, or a small molecule ligand, etc. is also seen as a residue.</p>
<h3 id="Get-residue-name"><a href="#Get-residue-name" class="headerlink" title="Get residue name"></a>Get residue name</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_20th = my_pose.residue(<span class="number">20</span>)</span><br><span class="line"><span class="comment"># my_pose is a `Pose` object</span></span><br><span class="line"><span class="comment"># residue_20th is a `Residue` object</span></span><br><span class="line">residue_20th_name = residue_20th.name()</span><br><span class="line"><span class="comment"># a string, the uppercased 3-letter name</span></span><br><span class="line"><span class="comment"># e.g. &#x27;ASP&#x27;</span></span><br><span class="line"></span><br><span class="line">residue_20th_base_name = residue_20th.base_name()</span><br><span class="line"><span class="comment"># a string, the uppercased 3-letter name</span></span><br><span class="line"><span class="comment"># e.g. &#x27;ASP&#x27;</span></span><br><span class="line"></span><br><span class="line">residue_20th_name3 = residue_20th.name3()</span><br><span class="line"><span class="comment"># a string, the uppercased 3-letter name</span></span><br><span class="line"><span class="comment">#e.g. &#x27;ASP&#x27;</span></span><br><span class="line"></span><br><span class="line">residue_20th_name1 = residue_20th.name1()</span><br><span class="line"><span class="comment"># a string, the uppercased 1-letter name</span></span><br><span class="line"><span class="comment">#e.g. &#x27;D&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Get-residue-property-is-xxx-booleans"><a href="#Get-residue-property-is-xxx-booleans" class="headerlink" title="Get residue property: is_xxx booleans"></a>Get residue property: <code>is_xxx</code> booleans</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_24th = my_pose.residue(<span class="number">24</span>) <span class="comment"># Get #24 residue from my_pose</span></span><br><span class="line">residue_24th_is_charged = residue_24th.is_charged() <span class="comment"># Boolean, `True` if it is charged</span></span><br><span class="line">residue_24th_is_aa = residue_24th.is_protein() <span class="comment"># Boolean, `True` if it is an amino acid</span></span><br></pre></td></tr></table></figure>

<h3 id="Get-atom-index"><a href="#Get-atom-index" class="headerlink" title="Get atom index"></a>Get atom index</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">residue_24th = my_pose.residue(<span class="number">24</span>) <span class="comment"># get #24 residue</span></span><br><span class="line">carbon_alpha_of_residue_24th = residue_24th.atom_index(<span class="string">&quot;CA&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>&quot;N&quot;</code>is the nitrogen of main-chain amino group.</p>
<p><code>&quot;CA&quot;</code>is the central carbon.</p>
<p><code>&quot;C&quot;</code>is the carbon of main-chain carboxyl group.</p>
<p>For atom nomenclatures, search for “amino acid structure”.</p>
<h3 id="Get-atom-xyz-coordinates-for-vector-related-calculations"><a href="#Get-atom-xyz-coordinates-for-vector-related-calculations" class="headerlink" title="Get atom xyz coordinates (for vector-related calculations)"></a>Get atom xyz coordinates (for vector-related calculations)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `residue_24th` is a residue in `my_pose`</span></span><br><span class="line">N_xyz = residue_24th.xyz(<span class="string">&quot;N&quot;</span>)</span><br><span class="line"><span class="comment"># N_xyz is a vector (length = 3)</span></span><br></pre></td></tr></table></figure>



<h2 id="PdbInfoclass"><a href="#PdbInfoclass" class="headerlink" title="PdbInfoclass"></a><code>PdbInfo</code>class</h2><p><code>PdbInfo</code>is a secondary class of <code>Pose</code>.</p>
<p>This class is a bridge between a <code>Pose</code> object and a PDB file:</p>
<ol>
<li>A <code>pdb_info</code>object stores information from the original PDB file (if the pose is from a pdb file or from the pdb database).</li>
<li>Or, this object stores information that can be written into a PDB file.</li>
</ol>
<h3 id="Convert-residue-ID-number-pdb2pose-and-pose2pdb"><a href="#Convert-residue-ID-number-pdb2pose-and-pose2pdb" class="headerlink" title="Convert residue ID (number): pdb2pose and pose2pdb"></a>Convert residue ID (number): <code>pdb2pose</code> and <code>pose2pdb</code></h3><p>The ID (number) of a residue starts at #1 in pose.</p>
<p>The ID of a residue in a <code>pose</code>object is different from its ID in a <code>.pdb</code>file.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In PDB file, a residue of interect is in &quot;chain A&quot;, and its ID (number) in the PDB file is 24</span></span><br><span class="line"><span class="comment"># But its ID in the `Pose` object (my_pose) is unknown.</span></span><br><span class="line">my_pdb_info = my_pose.pdb_info()</span><br><span class="line">my_residue_id_in_pose = my_pdb_info.pdb2pose(<span class="string">&#x27;A&#x27;</span>, <span class="number">24</span>) <span class="comment"># get the residue ID in pose, stored as an integer</span></span><br><span class="line">my_residue = my_pose.residue(my_residue_id_in_pose) <span class="comment"># get the `Residue` object by its ID in pose</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively, we can call the methods in a chain: </span></span><br><span class="line"><span class="comment"># my_residue_id_in_pose = my_pose.pdb_info().pdb2pose(&#x27;A&#x27;, 24)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># On the other hand, we can get the corresponding PDB chain infomation and ID information for a specific residue</span></span><br><span class="line"><span class="comment"># In a `Pose` object, a residue is at #1 position (its ID is 1), but its location in corresponding PDB file is unknown</span></span><br><span class="line">my_residue_info_in_pdb = my_pdb_info.pose2pdb(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># my_residue_info_in_pdb is a string that looks like &#x27;24 A&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Get-chain-information-Get-number-ID-information"><a href="#Get-chain-information-Get-number-ID-information" class="headerlink" title="Get chain information &amp; Get number (ID) information"></a>Get chain information &amp; Get number (ID) information</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a `Pose` instance called `my_pose`, and a residue of interest whose ID (in pose) is 1</span></span><br><span class="line">my_pose.pdb_info().chain(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; A</span></span><br><span class="line"><span class="comment"># The #1 residue is in &#x27;chain A&#x27;</span></span><br><span class="line">my_pose.pdb_info().number(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; 24</span></span><br><span class="line"><span class="comment"># The ID of #1 (in pose) residue in corresponding PDB file is 24</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-PdbInfo-name"><a href="#Set-PdbInfo-name" class="headerlink" title="Set PdbInfo name"></a>Set <code>PdbInfo</code> name</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assume that my_pose is a `pose` object</span></span><br><span class="line">my_pose.pdb_info().name(<span class="string">&quot;test&quot;</span>) </span><br><span class="line"><span class="comment"># set the name of this pose in its pdb_info as &quot;test&quot;</span></span><br><span class="line"><span class="comment"># if it is sent to PyMOL, it will be displayed as &quot;test&quot; in the object list</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-chain-split-chain"><a href="#Set-chain-split-chain" class="headerlink" title="Set chain (split chain)"></a>Set chain (split chain)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that my_pose is a `pose` object with a single chain, chain &quot;A&quot;.</span></span><br><span class="line"><span class="comment"># Assume that we are going to split the residues </span></span><br><span class="line"><span class="comment">#  from #101 to the end of the chain into chain &quot;B&quot;.</span></span><br><span class="line">pose = pose_from_pdb(<span class="string">&quot;myprotein.pdb&quot;</span>)</span><br><span class="line">pdbinfo = pose.pdb_info()</span><br><span class="line"><span class="comment"># Cut between residue 100 and 101 in the pose</span></span><br><span class="line">strand_start = <span class="number">101</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> <span class="built_in">range</span>(strand_start, pose.size() + <span class="number">1</span>):</span><br><span class="line">    pdb_info.chain(res, <span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Conformation-class"><a href="#Conformation-class" class="headerlink" title="Conformation  class"></a><code>Conformation </code> class</h2><h3 id="Get-bond-length-Get-bond-angle"><a href="#Get-bond-length-Get-bond-angle" class="headerlink" title="Get bond length &amp; Get bond angle"></a>Get bond length &amp; Get bond angle</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># given a `residue_id` (ID of a residue):</span></span><br><span class="line">residue_28th = my_pose.residue(residue_id) <span class="comment"># Get residue </span></span><br><span class="line">N28 = AtomID(residue_28th.atom_index(<span class="string">&quot;N&quot;</span>), residue_id) <span class="comment"># Construct an `AtomID` object for backbone nitrogen</span></span><br><span class="line">CA28 = AtomID(residue_28th.atom_index(<span class="string">&quot;CA&quot;</span>), residue_id)</span><br><span class="line">C28 = AtomID(res_28.atom_index(<span class="string">&quot;C&quot;</span>), resid)</span><br><span class="line"></span><br><span class="line">my_conformation = my_pose.conformation() <span class="comment"># Get conformation object</span></span><br><span class="line"></span><br><span class="line">N_CA_28_bond_length = my_conformation.bond_length(N28, CA28) <span class="comment"># get bond length; type is float</span></span><br><span class="line">bb_angle = my_conformation.bond_angle(N28, CA28, C28) <span class="comment"># get bond angle; type is float; in degree</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (10) HBNet</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(10)%20HBNet%20Mover/</url>
    <content><![CDATA[<h1 id="PyRosetta-10-HBNet"><a href="#PyRosetta-10-HBNet" class="headerlink" title="PyRosetta (10): HBNet"></a>PyRosetta (10): HBNet</h1><h2 id="Initiation"><a href="#Initiation" class="headerlink" title="Initiation"></a>Initiation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.rosetta_scripts.XmlObjects <span class="keyword">import</span> create_from_string</span><br></pre></td></tr></table></figure>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote>
<p><code>HBNet</code>for hydrogen bond network </p>
</blockquote>
<p>Rosetta HBNet is a protocol and scoring term designed to explicitly identify and optimize hydrogen bond networks during protein design.</p>
<p>It is an alternative or complement to Rosetta’s standard packing algorithms, which often favor hydrophobic interactions and can neglect complex polar networks. </p>
<p>HBNet was developed to address design problems where the cooperative, multi-body nature of hydrogen bond networks is critical, such as at protein-protein interfaces or in the protein core.</p>
<p>There are two main ways to use HBNet in Rosetta: as a <strong>Mover</strong> (<code>HBNet</code> or <code>MC HBNet</code>) or as a <strong>score term</strong> (<code>hbnet</code>)</p>
<h2 id="HBNet-Mover-Introduction"><a href="#HBNet-Mover-Introduction" class="headerlink" title="HBNet Mover Introduction"></a>HBNet Mover Introduction</h2><p>The original <code>HBNet</code> Mover and its modern, faster Monte Carlo-based version (<code>MC HBNet</code>) function as a pre-design step.</p>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>A two-stage design:</p>
<ol>
<li>running the <code>HBNet</code> mover to establish the polar network of selected residues (and get multiple output poses)</li>
<li>and then running a standard design protocol (like <code>FastDesign</code>within a<code>MultiplePoseMover</code> to optimize the surrounding hydrophobic residues.</li>
</ol>
<h3 id="HBNet-Mover-Process"><a href="#HBNet-Mover-Process" class="headerlink" title="HBNet Mover Process"></a>HBNet Mover Process</h3><p><strong>Methods</strong>: It conducts a stochastic search to find combinations of polar amino acid rotamers that can form extensive, self-contained hydrogen bond networks. </p>
<p>**Search process: **It builds a graph where nodes are possible rotamers and edges are possible hydrogen bonds. It then finds the best connected networks that satisfy certain criteria.</p>
<p><strong>Evaluation (Network quality metrics)</strong>: </p>
<ol>
<li>Satisfaction: The fraction of a network’s hydrogen bonding capacity that is met.</li>
<li>Number of unsatisfied polar atoms (“unsats”): HBNet specifically penalizes buried polar heavy atoms that do not form hydrogen bonds.</li>
</ol>
<p><strong>Output:</strong> The mover returns multiple <code>Pose</code> objects, each with a different optimal network placed. Each one is slightly worse than the previous by HBNet’s standards, but sub-optimal poses might have the potential for lower scores after the following <code>FastRelax</code>. </p>
<h2 id="HBNetStapleInterface-class"><a href="#HBNetStapleInterface-class" class="headerlink" title="HBNetStapleInterface class"></a><code>HBNetStapleInterface</code> class</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p><code>HBNetStapleInterface</code> is a HBNet mover for interface packing.</p>
<h3 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h3><h4 id="Instantiation-via-XML"><a href="#Instantiation-via-XML" class="headerlink" title="Instantiation via XML"></a>Instantiation via XML</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> setup_using_string:</span><br><span class="line">    hbnet = create_from_string(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;MOVERS&gt;</span></span><br><span class="line"><span class="string">    &lt;HBNetStapleInterface name=&quot;hbnet&quot; monte_carlo=&quot;true&quot; store_network_scores_in_pose=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/MOVERS&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>).get_mover(<span class="string">&quot;hbnet&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use a Monte Carlo version of HBNet by setting `monte_carlo` to &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># The `create_from_string` is at</span></span><br><span class="line"><span class="string">pyrosetta.rosetta.protocols.rosetta_scripts.XmlObjects.create_from_string</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Instantiation-via-PyRosetta-HBNetStapleInterface-class"><a href="#Instantiation-via-PyRosetta-HBNetStapleInterface-class" class="headerlink" title="Instantiation via PyRosetta HBNetStapleInterface class"></a>Instantiation via PyRosetta <code>HBNetStapleInterface</code> class</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet = HBNetStapleInterface()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">`set_monte_carlo_branch` turns on Monte Carlo version of HBNet.</span></span><br><span class="line"><span class="string">Same as `monte_carlo`</span></span><br><span class="line"><span class="string">This is highly recommended, </span></span><br><span class="line"><span class="string">  especially for large systems like asymmetric interfaces</span></span><br><span class="line"><span class="string">  see PMID: 29652499</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">hbnet.set_monte_carlo_branch( <span class="literal">True</span> )</span><br></pre></td></tr></table></figure>

<h3 id="A-Standard-run"><a href="#A-Standard-run" class="headerlink" title="A Standard run"></a>A Standard run</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet = HBNetStapleInterface()</span><br><span class="line">hbnet.set_monte_carlo_branch( <span class="literal">True</span> )</span><br><span class="line">hbnet.task_factory( my_task_factory )</span><br><span class="line">hbnet.set_score_function( my_scorefxn )</span><br><span class="line">hbnet.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h4 id="Allowing-chi-angles"><a href="#Allowing-chi-angles" class="headerlink" title="Allowing chi angles"></a>Allowing chi angles</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ex1ex2 = ExtraRotamersGeneric()</span><br><span class="line">ex1ex2.ex1( <span class="literal">True</span> )</span><br><span class="line">ex1ex2.ex2( <span class="literal">True</span> )</span><br><span class="line">my_task_factory.push_back( ex1ex2 )</span><br></pre></td></tr></table></figure>

<h3 id="Get-extra-output-poses"><a href="#Get-extra-output-poses" class="headerlink" title="Get extra output poses"></a>Get extra output poses</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># there were 10 (or so) networks total, </span></span><br><span class="line"><span class="comment">#  but let&#x27;s just try the next 5</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># In each python loop, the next pose is acquired</span></span><br><span class="line">    extra_pose = hbnet.get_additional_output()</span><br><span class="line">    <span class="keyword">if</span> extra_pose <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Create a design task</span></span><br><span class="line">    task_design = task_factory.create_task_and_apply_taskoperations( extra_pose )</span><br><span class="line">    <span class="comment"># Speed up</span></span><br><span class="line">    task_design.or_linmem_ig( <span class="literal">True</span> )</span><br><span class="line">    <span class="comment"># Create a pack mover</span></span><br><span class="line">    pack_mover = PackRotamersMover( scorefxn, task_design )</span><br><span class="line">    <span class="comment"># Apply the pack mover</span></span><br><span class="line">    pack_mover.apply( extra_pose )</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;Change in score&quot;</span>, scorefxn(extra_pose) - scorefxn(start_pose) )</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">`or_linmmem_ig( True )`: </span></span><br><span class="line"><span class="string">Recommended.</span></span><br><span class="line"><span class="string">Use the linear memory interaction graph whenever performing design. </span></span><br><span class="line"><span class="string">It&#x27;s a huge speed-up.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>get_additional_output</code>: this functionality can also be accessed via multistage_rosetta_scripts or the MultiplePoseMover in rosetta_scripts. See the rosetta_scripts_scripts repository for examples.</p>
<h3 id="HBNetStapleInterface-methods"><a href="#HBNetStapleInterface-methods" class="headerlink" title="HBNetStapleInterface  methods"></a><code>HBNetStapleInterface</code>  methods</h3><h4 id="Appoint-a-TaskFactory-object"><a href="#Appoint-a-TaskFactory-object" class="headerlink" title="Appoint a TaskFactory object"></a>Appoint a <code>TaskFactory</code> object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet.task_factory( my_task_factory )</span><br></pre></td></tr></table></figure>

<h4 id="Set-a-score-function"><a href="#Set-a-score-function" class="headerlink" title="Set a score function"></a>Set a <code>score function</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet.set_score_function( my_scorefxn )</span><br></pre></td></tr></table></figure>

<h4 id="Show-details-in-the-output-cell"><a href="#Show-details-in-the-output-cell" class="headerlink" title="Show details in the output cell"></a>Show details in the output cell</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet.verbose( <span class="literal">True</span> )</span><br></pre></td></tr></table></figure>

<h4 id="At-least-one-residue-is-buried"><a href="#At-least-one-residue-is-buried" class="headerlink" title="At least one residue is buried"></a>At least one residue is buried</h4><p>NOTICE: Highly recomended. Without it, HBNet tends to just design many surface networks that nobody really cares about.</p>
<p>Only branch from hbonds where at least one residue is buried. </p>
<p>Effectively, this results in only finding networks that have at least one buried residue.</p>
<p><code>set_monte_carlo_seed_must_be_buried</code> does two things:</p>
<ol>
<li>speeds us up by decreasing the sample space</li>
<li>ensures that our final hbond network will be at least partially buried</li>
</ol>
<p>commenting the following line out to give us more results:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet.set_monte_carlo_seed_must_be_buried( <span class="literal">True</span> )</span><br></pre></td></tr></table></figure>

<h4 id="At-least-a-pair-of-residues-is-buried"><a href="#At-least-a-pair-of-residues-is-buried" class="headerlink" title="At least a pair of residues is buried"></a>At least a pair of residues is buried</h4><p>Only branch from hbonds where both residues are buried. </p>
<p>This results in only finding networks that have at least one buried hbond but this does not prevent having additional exposed hbonds.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hbnet.set_monte_carlo_seed_must_be_fully_buried ( <span class="literal">True</span> )</span><br></pre></td></tr></table></figure>

<h4 id="Set-total-Monte-Carlo-runs"><a href="#Set-total-Monte-Carlo-runs" class="headerlink" title="Set total Monte Carlo runs"></a>Set total Monte Carlo runs</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We can normallly leave this as the default</span></span><br><span class="line"><span class="comment">#  making it smaller now to let it run faster</span></span><br><span class="line">hbnet.set_total_num_mc_runs( <span class="number">1000</span> )</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (11) Make Bundle Movers</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(11)%20Make%20Bundle%20Movers/</url>
    <content><![CDATA[<h1 id="Make-Bundle-Movers"><a href="#Make-Bundle-Movers" class="headerlink" title="Make Bundle Movers"></a>Make Bundle Movers</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MakeBundle generates a helical bundle using the Crick equations (which describe a helix of helices) or modified Crick equations (describing a laterally-squashed helix of helices).</p>
<p>This mover is general enough to create arbitrary helices using arbitrary backbones. Since strands are a special case of a helix (in which the turn per residue is about 180 degrees), the mover can also generate beta-barrels or other strand bundles. </p>
<p>The generated secondary structure elements are disconnected, so subsequent movers (e.g. <strong>GeneralizedKIC</strong>) must be invoked to connect them with loops.</p>
<p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/gpboo8e5bagpymvy">Note | Biochemistry Terms</a></p>
<h2 id="Major-Parameters"><a href="#Major-Parameters" class="headerlink" title="Major Parameters"></a>Major Parameters</h2><ol>
<li>**The super-helical radius (R0)**：the “major super halical radius”; the distances between helices, depending on the number of helices, ~3-10 Å</li>
<li><strong>The super helical frequency (ω0)</strong>: super-helix torsion; helix twists (curve) around Z axis; measured by “how each a.a. contribute to the curvature of a helix”, -2.5~2.5°(plus or minus determines the chirality)</li>
<li><strong>Helical phase offset (Δφ1) of a helix</strong>: the angle that the helix turns around its own central axis, relative to the initial helical phase (φ1), Δφ1 &#x3D; ω1·t<br>NOTICE: This is <strong>delta_omega1</strong> in Rosetta</li>
<li><strong>Super-helical phase offset (Δφ0) of a helix</strong>: the angle that the helix turns around the central axis of the super helix (the Z axis), relative to the initial super-helical phase (φ0), Δφ0 &#x3D; ω0·t<br>NOTICE: This is <strong>delta_omega0</strong> in Rosetta</li>
<li><strong>Chain axial offset (ΔZ) of a helix</strong>: the distance that a helix moves along the central Z axis of the super-helix</li>
<li><strong>The helical radius (R1)</strong>: α-helix radius, usually set to the ideal value of an α-helix</li>
<li><strong>The helical frequency (ω1)</strong>: α-helix curvature, coupled to  ω0, for an ideal  α-helix, ω0+ω1&#x3D;100°</li>
</ol>
<h2 id="BundleGridSampler-Mover-in-Rosetta"><a href="#BundleGridSampler-Mover-in-Rosetta" class="headerlink" title="BundleGridSampler Mover in Rosetta"></a>BundleGridSampler Mover in Rosetta</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.rosetta_scripts <span class="keyword">import</span> XmlObjects</span><br><span class="line">pose = pyrosetta.rosetta.core.pose.Pose() <span class="comment">#empty</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">  &lt;ScoreFunction name=&quot;sfxn1&quot; weights=&quot;ref2015&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;/SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">&lt;MOVERS&gt;</span></span><br><span class="line"><span class="string">    &lt;BundleGridSampler name=&quot;bgs1&quot;</span></span><br><span class="line"><span class="string">                     helix_length=&quot;20&quot;</span></span><br><span class="line"><span class="string">                     scorefxn=&quot;sfxn1&quot;</span></span><br><span class="line"><span class="string">                     r0_min=&quot;1.0&quot;</span></span><br><span class="line"><span class="string">                     r0_max=&quot;10.0&quot;</span></span><br><span class="line"><span class="string">                     r0_samples=&quot;10&quot;</span></span><br><span class="line"><span class="string">                     omega0=&quot;0.05&quot;</span></span><br><span class="line"><span class="string">                     delta_omega0=&quot;0&quot;</span></span><br><span class="line"><span class="string">                     delta_omega1=&quot;0&quot;</span></span><br><span class="line"><span class="string">                     delta_t=&quot;0&quot;</span></span><br><span class="line"><span class="string">                     dump_pdbs=&quot;0&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;Helix/&gt;</span></span><br><span class="line"><span class="string">      &lt;Helix delta_omega0=&quot;2.09&quot; r0_copies_helix=&quot;1&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;Helix delta_omega0=&quot;4.19&quot; r0_copies_helix=&quot;1&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/BundleGridSampler&gt;</span></span><br><span class="line"><span class="string">&lt;/MOVERS&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XmlObjects.create_from_string(my_str).get_mover(<span class="string">&quot;bgs1&quot;</span>).apply(pose)</span><br></pre></td></tr></table></figure>

<p>In this example, we allow rosetta to sample across a range of r0 values.</p>
<p>We created a bundle of 3 helices.</p>
<p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/csnn9en6aurumwqt">https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/csnn9en6aurumwqt</a></p>
<h2 id="MakeBundle-Mover-in-Rosetta"><a href="#MakeBundle-Mover-in-Rosetta" class="headerlink" title="MakeBundle Mover in Rosetta"></a>MakeBundle Mover in Rosetta</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>This script generates an antiparallel beta-barrel with a bundle of alpha-helices on the inside.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pose = pyrosetta.rosetta.core.pose.Pose() <span class="comment">#empty</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">  &lt;ScoreFunction name=&quot;sfxn1&quot; weights=&quot;ref2015&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;/SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">&lt;MOVERS&gt;</span></span><br><span class="line"><span class="string">    &lt;MakeBundle name=&quot;bundle1&quot; set_bondlengths=&quot;true&quot; set_bondangles=&quot;true&quot; residue_name=&quot;ALA&quot; crick_params_file=&quot;beta_strand&quot; symmetry=&quot;16&quot; r0=&quot;29&quot; omega0=&quot;0.075&quot; helix_length=&quot;20&quot; &gt;</span></span><br><span class="line"><span class="string">            #The parameters set above ensure that by default, each &quot;helix&quot; will actually be a strand:</span></span><br><span class="line"><span class="string">    	&lt;Helix /&gt; #A strand</span></span><br><span class="line"><span class="string">    	&lt;Helix delta_omega0=&quot;0.19634954&quot; invert=&quot;1&quot; delta_t=&quot;0.25&quot; delta_omega1=&quot;1.5707963&quot; /&gt; #An offset, inverted strand.</span></span><br><span class="line"><span class="string">    	&lt;Helix r0=&quot;21&quot; omega0=&quot;0.05&quot; crick_params_file=&quot;alpha_helix&quot; helix_length=&quot;40&quot; /&gt; #An alpha-helix.</span></span><br><span class="line"><span class="string">    	#The three elements defined above are repeated 16 times about the bundle axis to make the bundle.</span></span><br><span class="line"><span class="string">    &lt;/MakeBundle&gt;</span></span><br><span class="line"><span class="string">&lt;/MOVERS&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">XmlObjects.create_from_string(my_str).get_mover(<span class="string">&quot;bundle1&quot;</span>).apply(pose)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.nlark.com/yuque/0/2025/png/32767990/1756791112273-9e9a9ff8-48f5-4f47-bdfd-48212014f3f6.png"></p>
<h2 id="MakeBundle-mover-in-PyRosetta"><a href="#MakeBundle-mover-in-PyRosetta" class="headerlink" title="MakeBundle mover in PyRosetta"></a>MakeBundle mover in PyRosetta</h2><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.helical_bundle <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">pose = pyrosetta.rosetta.core.pose.Pose()</span><br><span class="line">mb = MakeBundle()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add 1st helix</span></span><br><span class="line">mb.add_helix() </span><br><span class="line"><span class="comment"># add 2nd helix</span></span><br><span class="line">mb.add_helix() </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">select the 2nd helix, </span></span><br><span class="line"><span class="string">and set the delta_omega0 value to 180°.</span></span><br><span class="line"><span class="string">delta_omega0: helix rotation around Z axis of the bundle of helices</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">mb.helix(<span class="number">2</span>).calculator_op().real_parameter(BPC_delta_omega0).set_value(math.pi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>): <span class="comment"># i in [1,2]</span></span><br><span class="line">    <span class="comment"># Set helix length to 20</span></span><br><span class="line">    mb.helix(i).set_helix_length(<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># set super-helix radius (major radius) `r0` to 5 (&gt;=3, &lt;=10)</span></span><br><span class="line">    mb.helix(i).calculator_op().real_parameter(BPC_r0).set_value(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># set torsion to 2.5°</span></span><br><span class="line">    mb.helix(i).calculator_op().real_parameter(BPC_omega0).set_value(math.radians(<span class="number">2.5</span>))</span><br><span class="line"></span><br><span class="line">mb.apply(pose)</span><br><span class="line">pose.dump_pdb(<span class="string">&quot;outputs/manual_make_bundle.pdb&quot;</span>)</span><br><span class="line">pmm.apply(pose)</span><br></pre></td></tr></table></figure>

<p>In this example, we created a bundle of 3 helices.</p>
<h2 id="α-helixParameter-tips"><a href="#α-helixParameter-tips" class="headerlink" title="α-helixParameter tips"></a>α-helixParameter tips</h2><blockquote>
<p>From Vikram Mulligan, the developer who invented Rosetta Parametric Backbone Design.</p>
</blockquote>
<ol>
<li>Most bundles would have r0 from 3 to 10 A (depending on the helix count).</li>
<li>Omega0 should range from about -2.5 degrees to 2.5 degrees.</li>
<li>Delta_omega1 can be anywhere from 0 to 360. (It’s just the roll of the helix about its own axis).</li>
<li>Delta_z0, delta_z1 or delta_t can be anything (you’re just sliding the helix up and down). Typically, you’d just sample around a few Angstroms, though.</li>
<li>r1, omega1, etc. are all minor helix parameters that are tied to the secondary structure. We don’t normally vary them.</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/movers_pages/MakeBundleMover">MakeBundle</a></p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (12) VirtualRoot Mover</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(12)%20Virtual-Root%20Mover/</url>
    <content><![CDATA[<h1 id="PyRosetta-12-VirtualRoot-Mover"><a href="#PyRosetta-12-VirtualRoot-Mover" class="headerlink" title="PyRosetta (12): VirtualRoot Mover"></a>PyRosetta (12): VirtualRoot Mover</h1><h2 id="Introduction-to-VirtualRootMover"><a href="#Introduction-to-VirtualRootMover" class="headerlink" title="Introduction to VirtualRootMover"></a>Introduction to <code>VirtualRootMover</code></h2><p>In PyRosetta, adding a “virtual root” to a <code>Pose</code> when using coordinate constraints helps prevent large, unintended structural shifts by creating a stable reference point for the energy calculations. Its role is to anchor the entire molecule and prevent “lever-arm effects,” which can cause distortion during minimization. </p>
<h3 id="What-is-a-“lever-arm-effect”"><a href="#What-is-a-“lever-arm-effect”" class="headerlink" title="What is a “lever-arm effect”?"></a><strong>What is a “lever-arm effect”?</strong></h3><p>Rosetta minimizes molecular energy by manipulating a protein’s internal coordinates—such as the torsion angles of its backbone and sidechains. When a torsion angle is changed, all the atoms “downstream” of that bond (i.e., further away from the root of the molecule’s <code>FoldTree</code>) will shift in space. </p>
<p>Consider a simple, long rod. If you fix one end (the root) and push the other, it will just move. But if you fix a point somewhere in the middle, pushing one end will cause a large, exaggerated movement of the other end, like a lever. This is the lever-arm effect. </p>
<p>In a protein, without a properly placed root, a small adjustment to a torsion angle far from the root can cause a massive and non-physical movement of the atoms at the end of the chain, breaking the coordinate constraints applied to them. </p>
<h3 id="How-the-VirtualRootMover-helps"><a href="#How-the-VirtualRootMover-helps" class="headerlink" title="How the **VirtualRootMover** helps"></a><strong>How the <strong><code>**VirtualRootMover**</code></strong> helps</strong></h3><p>The <code>VirtualRootMover</code> addresses this problem by doing two things:</p>
<ol>
<li><strong>It adds a new, fake residue to the</strong>** **<code>**Pose**</code>. This residue is given special properties that make it a virtual point of reference that does not participate in the protein’s chemistry.</li>
<li><strong>It changes the</strong>** <strong><code>**Pose**</code></strong>‘s**** <strong><code>**FoldTree**</code></strong> **<strong>so this new residue becomes the root</strong>. The <code>FoldTree</code> is the kinematic tree that defines how all the residues are connected. By making the virtual residue the root, you ensure that any minimization moves will be calculated relative to this fixed, neutral point.</li>
</ol>
<h3 id="Role-when-using-coordinate-constraints"><a href="#Role-when-using-coordinate-constraints" class="headerlink" title="Role when using coordinate constraints"></a><strong>Role when using coordinate constraints</strong></h3><p>When you apply coordinate constraints, you are telling Rosetta to add an energy penalty if certain atoms move too far from their initial position. This is crucial for protocols that need to preserve a structure’s overall shape. </p>
<p>The virtual root prevents the protein from moving as a single, large, flexible unit in Cartesian space. Instead, all movements are calculated relative to the virtual residue, which is fixed in space. This prevents the large-scale “lever-arm” movements and ensures that the minimization process properly respects the coordinate constraints by only allowing local, subtle adjustments. </p>
<p>In summary, the <code>VirtualRootMover</code> is a vital tool for ensuring that energy minimization with coordinate constraints is stable and produces physical results by providing a rigid, fixed anchor for the entire protein. </p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apply a virtual root onto the pose to prevent large lever-arm effects while minimizing with coordinate constraints</span></span><br><span class="line">virtual_root = pyrosetta.rosetta.protocols.simple_moves.VirtualRootMover()</span><br><span class="line">virtual_root.set_removable(<span class="literal">True</span>)</span><br><span class="line">virtual_root.set_remove(<span class="literal">False</span>)</span><br><span class="line">virtual_root.apply(my_pose)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (13) Constraint Generator</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(13)%20Constraint%20Generator%20Movers/</url>
    <content><![CDATA[<h1 id="PyRosetta-13-Constraint-Generator"><a href="#PyRosetta-13-Constraint-Generator" class="headerlink" title="PyRosetta (13): Constraint Generator"></a>PyRosetta (13): Constraint Generator</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Constraint-functions"><a href="#Constraint-functions" class="headerlink" title="Constraint functions"></a>Constraint functions</h3><h4 id="Harmonic-HARMONIC"><a href="#Harmonic-HARMONIC" class="headerlink" title="Harmonic: HARMONIC"></a>Harmonic: <code>HARMONIC</code></h4><p>A harmonic constraint uses a simple parabola (a squared function) to apply a penalty. </p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/gif/32767990/1756801826076-cb2bdec1-c6cc-4207-97cd-81cb505c5e28.gif">$ E&#x3D;(\frac{x−x_0}{\sigma})^2 $</p>
<p> where $ \sigma $is a force constant, $ x $ is the measured value, and $ x_0 $ is the ideal value. </p>
<p>![](PyRosetta (13) Constraint Generator Movers.assets&#x2F;1756802935061-72f8eb91-7309-4f80-81b3-c20f109b7a73.png)</p>
<h4 id="Bounded-Flat-harmonic-FLAT-HARMONIC"><a href="#Bounded-Flat-harmonic-FLAT-HARMONIC" class="headerlink" title="Bounded (Flat harmonic: FLAT_HARMONIC)"></a>Bounded (Flat harmonic: <code>FLAT_HARMONIC</code>)</h4><p>A bounded constraint defines a flat-bottomed energy well. It has two key parameters: a minimum bound $ lb &#x3D; x_0 - t $ and a maximum bound $ ub &#x3D; x_0 + t $.</p>
<p>Similar to <code>HARMONIC</code>, but is 0 (“flat”) around $ \pm $tolerance (t).</p>
<p>$ E&#x3D;  (\frac{x−x_0}{\sigma})^2 - (\frac{t}{\sigma})^2, \ x\ge x_0 + t \ \text{or} \ x\le x_0 -t $</p>
<p>$ E &#x3D; 0, \ x_0 - t \le x \le x_0 + t $</p>
<p>![](PyRosetta (13) Constraint Generator Movers.assets&#x2F;1756802945356-1aba79e7-063a-4e4a-87de-818d86d4d6e0-1757296044272-5.png)</p>
<p>If the measured value $ x $ is within the bounds ($ lb\le x\le ub\ $), the energy penalty is 0.</p>
<p>If the measured value is outside the bounds $ x&lt;lb $ or $ x&gt;ub $, a penalty is applied that increases with the deviation, often harmonically.</p>
<p>Behavior: Instead of a “spring”, it creates a “box” or “well”. Any conformation within the specified range is considered equally good and incurs no penalty. Only when the conformation leaves this range is it penalized.</p>
<p>Best for situations where we want to allow some flexibility while preventing major structural excursions.</p>
<h3 id="Ambiguous-Constraints"><a href="#Ambiguous-Constraints" class="headerlink" title="Ambiguous Constraints"></a>Ambiguous Constraints</h3><p>For certain amino acids, the position of an atom can be ambiguous due to the symmetry of the sidechain or because the sidechain can adopt different rotamers. </p>
<p>How ambiguous constraints work:</p>
<ul>
<li>In the sidechains of these three amino acids, certain atoms can swap positions. For example, in asparagine, the oxygen (OD1) and nitrogen (ND2) can swap places.</li>
<li>During a minimization step, the constraint would tether the atom to whichever of its ambiguous reference positions is currently closer. This allows the sidechain to flip between rotamers without incurring a large energy penalty from the constraint.</li>
</ul>
<h2 id="CoordinateConstraintGenerator"><a href="#CoordinateConstraintGenerator" class="headerlink" title="CoordinateConstraintGenerator"></a><code>CoordinateConstraintGenerator</code></h2><h3 id="Instantiation-of-CoordinateConstraintGenerator"><a href="#Instantiation-of-CoordinateConstraintGenerator" class="headerlink" title="Instantiation of CoordinateConstraintGenerator"></a>Instantiation of <code>CoordinateConstraintGenerator</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen = pyrosetta.rosetta.protocols.constraint_generator.CoordinateConstraintGenerator()</span><br></pre></td></tr></table></figure>

<h3 id="Example-of-CoordinateConstraintGenerator"><a href="#Example-of-CoordinateConstraintGenerator" class="headerlink" title="Example of CoordinateConstraintGenerator"></a>Example of <code>CoordinateConstraintGenerator</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen = pyrosetta.rosetta.protocols.constraint_generator.CoordinateConstraintGenerator()</span><br></pre></td></tr></table></figure>

<h4 id="Setup-Constrants"><a href="#Setup-Constrants" class="headerlink" title="Setup Constrants"></a>Setup Constrants</h4><p>WARNING: It is recomended to add a virtual root before adding constraints</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_selector = pyrosetta.rosetta.core.select.residue_selector.TrueResidueSelector() <span class="comment"># Select all residues</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the CoordinateConstraintGenerator</span></span><br><span class="line">coord_constraint_gen = pyrosetta.rosetta.protocols.constraint_generator.CoordinateConstraintGenerator()</span><br><span class="line">coord_constraint_gen.set_id(<span class="string">&quot;contrain_all_backbone_atoms!&quot;</span>)</span><br><span class="line">coord_constraint_gen.set_ambiguous_hnq(<span class="literal">False</span>)</span><br><span class="line">coord_constraint_gen.set_bounded(<span class="literal">False</span>)</span><br><span class="line">coord_constraint_gen.set_sidechain(<span class="literal">False</span>)</span><br><span class="line">coord_constraint_gen.set_sd(<span class="number">1.0</span>) </span><br><span class="line">coord_constraint_gen.set_ca_only(<span class="literal">False</span>)</span><br><span class="line">coord_constraint_gen.set_residue_selector(true_selector)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the CoordinateConstraintGenerator using the AddConstraints mover</span></span><br><span class="line">add_constraints = pyrosetta.rosetta.protocols.constraint_generator.AddConstraints()</span><br><span class="line">add_constraints.add_generator(coord_constraint_gen)</span><br><span class="line">add_constraints.apply(pose)</span><br></pre></td></tr></table></figure>

<h4 id="Remove-Constraints"><a href="#Remove-Constraints" class="headerlink" title="Remove Constraints"></a>Remove Constraints</h4><p>Remove constraints before direct (manual) pose manipulation.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">remove_constraints = pyrosetta.rosetta.protocols.constraint_generator.RemoveConstraints()</span><br><span class="line">remove_constraints.add_generator(coord_constraint_gen)</span><br><span class="line">remove_constraints.apply(pose)</span><br></pre></td></tr></table></figure>

<h3 id="Configuration-Options-of-CoordinateConstraintGenerator"><a href="#Configuration-Options-of-CoordinateConstraintGenerator" class="headerlink" title="Configuration Options of CoordinateConstraintGenerator"></a>Configuration Options of <code>CoordinateConstraintGenerator</code></h3><h4 id="Set-ID-for-CoordinateConstraintGenerator"><a href="#Set-ID-for-CoordinateConstraintGenerator" class="headerlink" title="Set ID for CoordinateConstraintGenerator"></a>Set ID for <code>CoordinateConstraintGenerator</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_id(<span class="string">&quot;contrain_all_backbone_atoms!&quot;</span>) </span><br><span class="line"><span class="comment"># Set the identifier of this generator</span></span><br></pre></td></tr></table></figure>

<h4 id="set-ambiguous-hnq"><a href="#set-ambiguous-hnq" class="headerlink" title="set_ambiguous_hnq"></a><code>set_ambiguous_hnq</code></h4><p><code>set_ambiguous_hnq</code> is a hardcoded shortcut to enable&#x2F;disable tracking of both possible symmetrical positions for ambiguous-hydrgen-related atoms in Histone, Asparagine and Glutamine.</p>
<p>If set to false, the constraint generator will apply a standard, non-ambiguous constraint to the specified atom positions.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_ambiguous_hnq(<span class="literal">False</span>) </span><br><span class="line"><span class="comment"># Histone, Asparagine, and Glutamine</span></span><br></pre></td></tr></table></figure>

<p>NOTICE: ambiguous atoms also exists in Asparatate (D), Glutamate (E), Phenyalanine (F), tyrosine (Y). D and E are handled by Rosetta Atom Types (OOC). And the built-in packer explores both symmetrical orientations of the ring. To specify customized constraints, use<code>**AmbiguousConstraint**</code>in a constraint file.</p>
<h4 id="Switch-between-bounded-or-harmonic-constraints"><a href="#Switch-between-bounded-or-harmonic-constraints" class="headerlink" title="Switch between bounded or harmonic constraints"></a>Switch between bounded or harmonic constraints</h4><p>whether to use harmonic (false) or bounded (true) constraints</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_bounded(true)</span><br><span class="line"><span class="comment"># If set bounded true:</span></span><br><span class="line">coord_constraint_gen.set_bounded_width(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Constraint-all-constraint-backbone"><a href="#Constraint-all-constraint-backbone" class="headerlink" title="Constraint all &#x2F; constraint backbone"></a>Constraint all &#x2F; constraint backbone</h4><p>Constrain all heavy atoms (false), or only backbone heavy atoms (true)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_sidechain(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Standard-deviation-RMSD-constraints"><a href="#Standard-deviation-RMSD-constraints" class="headerlink" title="Standard deviation RMSD constraints"></a>Standard deviation RMSD constraints</h4><p>The strength&#x2F;deviation of the constraints to use.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Sets a standard deviation of contrained atoms to (an arbitrary) 1.0 Angstroms RMSD. </span></span><br><span class="line"><span class="string">Set higher or lower for different results.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">coord_constraint_gen.set_sd(<span class="number">1.0</span>) </span><br></pre></td></tr></table></figure>

<h4 id="CA-only"><a href="#CA-only" class="headerlink" title="CA only"></a>CA only</h4><p>Only CA atoms are constrained.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_ca_only(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Apply-to-a-Selector-object"><a href="#Apply-to-a-Selector-object" class="headerlink" title="Apply to a Selector object"></a>Apply to a <code>Selector</code> object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord_constraint_gen.set_residue_selector(my_selector)</span><br></pre></td></tr></table></figure>

<h4 id="AddCompositionConstraintMover-from-XML"><a href="#AddCompositionConstraintMover-from-XML" class="headerlink" title="AddCompositionConstraintMover from XML"></a><code>AddCompositionConstraintMover</code> from XML</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_composition_constraint = pyrosetta.rosetta.protocols.aa_composition.AddCompositionConstraintMover()</span><br><span class="line">add_composition_constraint.create_constraint_from_file_contents(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">PENALTY_DEFINITION</span></span><br><span class="line"><span class="string">OR_PROPERTIES AROMATIC ALIPHATIC</span></span><br><span class="line"><span class="string">NOT_TYPE LEU</span></span><br><span class="line"><span class="string">FRACT_DELTA_START -0.05</span></span><br><span class="line"><span class="string">FRACT_DELTA_END 0.05</span></span><br><span class="line"><span class="string">PENALTIES 1 0 1 # The above two lines mean that if we&#x27;re 5% below or 5% above the desired content, we get a 1-point penalty.</span></span><br><span class="line"><span class="string">FRACTION 0.4 # Forty percent aromatic or aliphatic, but not leucine</span></span><br><span class="line"><span class="string">BEFORE_FUNCTION CONSTANT</span></span><br><span class="line"><span class="string">AFTER_FUNCTION CONSTANT</span></span><br><span class="line"><span class="string">END_PENALTY_DEFINITION</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">PENALTY_DEFINITION</span></span><br><span class="line"><span class="string">TYPE LEU</span></span><br><span class="line"><span class="string">DELTA_START -1</span></span><br><span class="line"><span class="string">DELTA_END 1</span></span><br><span class="line"><span class="string">PENALTIES 1 0 1</span></span><br><span class="line"><span class="string">FRACTION 0.05 # Five percent leucine</span></span><br><span class="line"><span class="string">BEFORE_FUNCTION CONSTANT</span></span><br><span class="line"><span class="string">AFTER_FUNCTION CONSTANT</span></span><br><span class="line"><span class="string">END_PENALTY_DEFINITION</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">add_composition_constraint.add_residue_selector(chain_A)</span><br><span class="line">add_composition_constraint.apply(pose)</span><br></pre></td></tr></table></figure>

<h2 id="AddHelixSequenceConstraintsMover"><a href="#AddHelixSequenceConstraintsMover" class="headerlink" title="AddHelixSequenceConstraintsMover"></a><code>AddHelixSequenceConstraintsMover</code></h2><p> Apply the AddHelixSequenceConstraints mover, which utilizes the aa_composition scoreterm. By default, this mover adds five types of sequence constraints to the designable residues in each alpha helix in the pose. Any of these behaviours may be disabled or modified by invoking advanced options, but no advanced options need be set in most cases. The five types of sequence constraints are:</p>
<ol>
<li>A strong sequence constraint requiring at least two negatively-charged residues in the first (N-terminal) three residues of each alpha-helix.</li>
<li>A strong sequence constraint requiring at least two positively-charged residues in the last (C-terminal) three residues of each alpha-helix.</li>
<li>A weak but strongly ramping sequence constraint penalizing helix-disfavoring residue types (by default, Asn, Asp, Ser, Gly, Thr, and Val) throughout each helix. (A single such residue is sometimes tolerated, but the penalty for having more than one residue in this category increases quadratically with the count of helix-disfavouring residues.)</li>
<li>A weak sequence constraint coaxing the helix to have 10% alanine. Because this constraint is weak, deviations from this value are tolerated, but this should prevent an excessive abundance of alanine residues.</li>
<li>A weak sequence constraint coaxing the helix to have at least 25% hydrophobic content. This constraint is also weak, so slightly less hydrophobic helices will be tolerated to some degree. Note that alanine is not considered to be “hydrophobic” within Rosetta.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_helix_sequence_constraints = pyrosetta.rosetta.protocols.aa_composition.AddHelixSequenceConstraintsMover()</span><br><span class="line">add_helix_sequence_constraints.set_residue_selector(chain_A)</span><br><span class="line">add_helix_sequence_constraints.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h2 id="AddNetChargeConstraintMover"><a href="#AddNetChargeConstraintMover" class="headerlink" title="AddNetChargeConstraintMover"></a><code>AddNetChargeConstraintMover</code></h2><p>Apply the AddNetChargeConstraintMover mover, which utilizes the netcharge scoreterm. </p>
<p>We require that the net charge in selected region must be exactly 0.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_net_charge_constraint = pyrosetta.rosetta.protocols.aa_composition.AddNetChargeConstraintMover()</span><br><span class="line">add_net_charge_constraint.create_constraint_from_file_contents(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">DESIRED_CHARGE 0 #Desired net charge is zero.</span></span><br><span class="line"><span class="string">PENALTIES_CHARGE_RANGE -1 1 #Penalties are listed in the observed net charge range of -1 to +1.</span></span><br><span class="line"><span class="string">PENALTIES 1 0 1 #The penalties are 1 for an observed charge of -1, 0 for an observed charge of 0, and 1 for an observed charge of +1.</span></span><br><span class="line"><span class="string">BEFORE_FUNCTION QUADRATIC #Ramp quadratically for observed net charges of -2 or less.</span></span><br><span class="line"><span class="string">AFTER_FUNCTION QUADRATIC #Ramp quadratically for observed net charges of +2 or greater.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">add_net_charge_constraint.add_residue_selector(chain_A)</span><br><span class="line">add_net_charge_constraint.apply(my_pose)</span><br></pre></td></tr></table></figure>





<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/58897635">https://zhuanlan.zhihu.com/p/58897635</a></p>
<p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/movers_pages/constraint_generators/constraint_generators/CoordinateConstraintGenerator">CoordinateConstraintGenerator</a></p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (14) Keep Region Mover</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(14)%20Keep%20Region%20Mover/</url>
    <content><![CDATA[<h1 id="PyRosetta-14-Keep-Region-Mover"><a href="#PyRosetta-14-Keep-Region-Mover" class="headerlink" title="PyRosetta (14): Keep Region Mover"></a>PyRosetta (14): Keep Region Mover</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Keep the residues in the selected range.</p>
<h2 id="Initiation"><a href="#Initiation" class="headerlink" title="Initiation"></a>Initiation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.grafting.simple_movers <span class="keyword">import</span> KeepRegionMover</span><br></pre></td></tr></table></figure>

<h2 id="Instantiation-Configuration-of-KeepRegionMover"><a href="#Instantiation-Configuration-of-KeepRegionMover" class="headerlink" title="Instantiation &amp; Configuration of KeepRegionMover"></a>Instantiation &amp; Configuration of <code>KeepRegionMover</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keep_ch2 = KeepRegionMover(res_start=<span class="built_in">str</span>(my_pose.chain_begin(<span class="number">2</span>)), res_end=<span class="built_in">str</span>(my_pose.chain_end(<span class="number">2</span>)-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Apply-the-mover-to-the-Pose-object"><a href="#Apply-the-mover-to-the-Pose-object" class="headerlink" title="Apply the mover to the Pose object"></a>Apply the mover to the <code>Pose</code> object</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keep_ch2.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h2 id="Note-concatenation"><a href="#Note-concatenation" class="headerlink" title="Note: concatenation"></a>Note: concatenation</h2><p>On the contrary, we can concatenate 2 poses into 1 pose:</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;pyrosetta.rosetta.core.pose.append_pose_to_pose(pose1=pose_A, pose2=pose_BC, new_chain=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (15) Rigid Body Movers &amp; Docking</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(15)%20Rigid%20Body%20Movers/</url>
    <content><![CDATA[<h1 id="PyRosetta-15-Rigid-Body-Movers-Docking"><a href="#PyRosetta-15-Rigid-Body-Movers-Docking" class="headerlink" title="PyRosetta (15): Rigid Body Movers &amp; Docking"></a>PyRosetta (15): Rigid Body Movers &amp; Docking</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The fundamental docking move is a rigid-body transformation consisting of a translation and rotation. Any rigid body move also needs to know which part moves and which part is fixed. In Rosetta, this division is known as a Jump and the set of protein segments and jumps are stored in an object attached to a pose called a <code>FoldTree</code>.</p>
<p>Rigid body movers are components of protein docking protocols.</p>
<h2 id="Initiation"><a href="#Initiation" class="headerlink" title="Initiation"></a>Initiation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyrosetta</span><br><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> rosetta</span><br><span class="line"><span class="keyword">import</span> pyrosetta.rosetta.protocols.rigid <span class="keyword">as</span> rigid</span><br><span class="line"><span class="keyword">import</span> pyrosetta.rosetta.protocols.docking <span class="keyword">as</span> docking</span><br><span class="line">pyrosetta.init()</span><br></pre></td></tr></table></figure>

<h2 id="Manual-rotation-and-translation"><a href="#Manual-rotation-and-translation" class="headerlink" title="Manual rotation and translation"></a>Manual rotation and translation</h2><h3 id="RigidBodySpinMover-class"><a href="#RigidBodySpinMover-class" class="headerlink" title="RigidBodySpinMover class"></a><code>RigidBodySpinMover</code> class</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load pose</span></span><br><span class="line">pose = pyrosetta.pose_from_pdb(<span class="string">&quot;input.pdb&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># instantiating RigidBodyTransMover</span></span><br><span class="line">trans_mover = rigid.RigidBodyTransMover(pose, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># set Z-axis as the translation (sliding); Set sliding distance to 5 Å</span></span><br><span class="line">trans_axis = rosetta.numeric.xyzVector_double_t(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">trans_mover.trans_axis(trans_axis)</span><br><span class="line">trans_mover.step_size(<span class="number">5.0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># apply RigidBodyTransMover</span></span><br><span class="line">trans_mover.apply(pose)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># save pose as pdb</span></span><br><span class="line">pose.dump_pdb(<span class="string">&quot;translated_output.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="RigidBodyTransMover-class"><a href="#RigidBodyTransMover-class" class="headerlink" title="RigidBodyTransMover class"></a><code>RigidBodyTransMover</code> class</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load pose</span></span><br><span class="line">pose = pyrosetta.pose_from_pdb(<span class="string">&quot;input.pdb&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Instantiating RigidBodySpinMover</span></span><br><span class="line">spin_mover = rigid.RigidBodySpinMover()</span><br><span class="line">rotation_axis = xyzVector_double_t(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">rotation_angle = <span class="number">45.0</span>  <span class="comment"># degree</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set spin axis</span></span><br><span class="line">spin_mover.spin_axis(rotation_axis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rotation angle (in degree)</span></span><br><span class="line">spin_mover.spin_mag(rotation_angle)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Apply RigidBodySpinMover</span></span><br><span class="line">spin_mover.apply(pose)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># save pose as pdb</span></span><br><span class="line">pose.dump_pdb(<span class="string">&quot;spinned_output.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="RigidBodyRandomizeMover"><a href="#RigidBodyRandomizeMover" class="headerlink" title="RigidBodyRandomizeMover"></a><code>RigidBodyRandomizeMover</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sliding 1st jump</span></span><br><span class="line">jump_num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># `partner_upstream`: the first chain in pose</span></span><br><span class="line"><span class="comment"># `partner_downstream`: the second chain in pose</span></span><br><span class="line">randomize1 = rigid.RigidBodyRandomizeMover(my_pose, jump_num, rigid.partner_upstream)</span><br><span class="line">randomize2 = rigid.RigidBodyRandomizeMover(my_pose, jump_num, rigid.partner_downstream)</span><br></pre></td></tr></table></figure>

<h2 id="Slide-into-contact-DockingSlideIntoContactMover-FADockingSlideIntoContactMover"><a href="#Slide-into-contact-DockingSlideIntoContactMover-FADockingSlideIntoContactMover" class="headerlink" title="Slide into contact: DockingSlideIntoContactMover&#x2F; FADockingSlideIntoContactMover"></a>Slide into contact: <code>DockingSlideIntoContactMover</code>&#x2F; <code>FADockingSlideIntoContactMover</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load pose</span></span><br><span class="line">pose = pyrosetta.pose_from_pdb(<span class="string">&quot;input.pdb&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Instantiating DockingSlideIntoContactMover</span></span><br><span class="line">slide_mover = docking.DockingSlideIntoContactMover(<span class="number">1</span>)  <span class="comment"># sliding jump 1</span></span><br><span class="line"><span class="comment">#slide_mover = FaDockingSlideIntoContact(jump_num)  # for full-atom mode</span></span><br><span class="line">slide_mover.apply(pose)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Save pose</span></span><br><span class="line">pose.dump_pdb(<span class="string">&quot;slide_into_contact_output.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Low-Resolution-Global-Docking-Mover-DockingLowRes"><a href="#Low-Resolution-Global-Docking-Mover-DockingLowRes" class="headerlink" title="Low Resolution Global Docking Mover: DockingLowRes"></a>Low Resolution Global Docking Mover: <code>DockingLowRes</code></h2><blockquote>
<p>The argument <code>&quot;A_B&quot;</code> tells Rosetta to make chain A the “rigid” chain and allow chain B to move. </p>
<p>If there were more chains in the pdb structure, supplying <code>&quot;AB_C&quot;</code> would hold chains A and B rigid together as a single unit and allow chain C to move. </p>
<p>The third argument <code>Vector1([1])</code> is required, it creates a Rosetta vector object — indexed from 1 — with one element that identifies the first Jump in the <code>FoldTree</code> for docking use.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `Pose` object named `cen_pose`</span></span><br><span class="line"><span class="comment"># 1st jump</span></span><br><span class="line">jump_num = <span class="number">1</span></span><br><span class="line">dock_lowres = DockingLowRes(scorefxn_low, jump_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup Fold Tree</span></span><br><span class="line">setup_foldtree(cen_pose,<span class="string">&quot;A_B&quot;</span>,Vector1([<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply to cen_pose</span></span><br><span class="line">dock_lowres.apply(cen_pose)</span><br></pre></td></tr></table></figure>

<h2 id="High-Resolution-Global-Docking-Mover-DockMCMProtocol"><a href="#High-Resolution-Global-Docking-Mover-DockMCMProtocol" class="headerlink" title="High Resolution Global Docking Mover: DockMCMProtocol"></a>High Resolution Global Docking Mover: <code>DockMCMProtocol</code></h2><p>The high-resolution stage of <code>RosettaDock</code> is also available as a <code>Mover</code>. This mover encompasses random rigid-body moves, side-chain packing, and gradient-based minimization in the rigid-body coordinates. High-resolution docking needs an all-atom score function. The optimized docking weights are available as a patch to the standard all-atom energy function.</p>
<p>Unlike for <code>DockingLowRes</code>, we must supply the docking partners with <code>&quot;A_B&quot;</code> instead of <code>jump_num</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `Pose` object named `cen_pose`</span></span><br><span class="line">scorefxn_high = create_score_function(<span class="string">&quot;ref2015.wts&quot;</span>, <span class="string">&quot;docking&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiating high resolution global docking mover</span></span><br><span class="line">dock_hi_res = DockMCMProtocol()</span><br><span class="line">dock_hi_res.set_scorefxn(scorefxn_high)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup Fold Tree</span></span><br><span class="line">setup_foldtree(cen_pose,<span class="string">&quot;A_B&quot;</span>,Vector1([<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">dock_hi_res.set_partners(<span class="string">&quot;A_B&quot;</span>)  <span class="comment"># make sure the FoldTree is set up properly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply</span></span><br><span class="line">dock_hi_res.apply(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the side chains from the original monomer structures</span></span><br><span class="line">recover_sidechains = ReturnSidechainMover(starting_pose)</span><br><span class="line">recover_sidechains.apply(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or, we can use a `PackRotamersMover`</span></span><br><span class="line"><span class="comment"># my_tf = TaskFactory()</span></span><br><span class="line"><span class="comment"># my_tf.push_back(operation.InitializeFromCommandline()) </span></span><br><span class="line"><span class="comment"># my_tf.push_back(operation.RestrictToRepacking()) </span></span><br><span class="line"><span class="comment"># my_packer = pyrosetta.rosetta.protocols.minimization_packing.PackRotamersMover() </span></span><br><span class="line"><span class="comment"># my_packer.task_factory(my_tf) </span></span><br><span class="line"><span class="comment"># my_packer.apply(my_pose)</span></span><br></pre></td></tr></table></figure>

<h2 id="Docking-Using-XML"><a href="#Docking-Using-XML" class="headerlink" title="Docking Using XML"></a>Docking Using XML</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xml = pyrosetta.rosetta.protocols.rosetta_scripts.XmlObjects.create_from_string(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;ROSETTASCRIPTS&gt;</span></span><br><span class="line"><span class="string">  &lt;SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">    &lt;ScoreFunction name=&quot;fa_standard&quot; weights=&quot;ref2015.wts&quot;/&gt; `ref2015.wts` score function</span></span><br><span class="line"><span class="string">  &lt;/SCOREFXNS&gt;</span></span><br><span class="line"><span class="string">  &lt;RESIDUE_SELECTORS&gt;</span></span><br><span class="line"><span class="string">    &lt;Chain name=&quot;chX&quot; chains=&quot;X&quot;/&gt; select chain &quot;X&quot; in pose</span></span><br><span class="line"><span class="string">  &lt;/RESIDUE_SELECTORS&gt;</span></span><br><span class="line"><span class="string">  &lt;SIMPLE_METRICS&gt;</span></span><br><span class="line"><span class="string">    &lt;RMSDMetric name=&quot;rmsd_chX&quot; residue_selector=&quot;chX&quot; reference_name=&quot;store_native&quot; residue_selector_ref=&quot;chX&quot; robust=&quot;true&quot; rmsd_type=&quot;rmsd_all&quot; /&gt; </span></span><br><span class="line"><span class="string">    Measurement using RMSD of chain X</span></span><br><span class="line"><span class="string">  &lt;/SIMPLE_METRICS&gt;</span></span><br><span class="line"><span class="string">  &lt;SCORINGGRIDS ligand_chain=&quot;X&quot; width=&quot;25&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;ClassicGrid grid_name=&quot;vdw&quot; weight=&quot;1.0&quot;/&gt; </span></span><br><span class="line"><span class="string">    Grids are recalculated if any non-ligand atoms change position. </span></span><br><span class="line"><span class="string">    The weight specified for each grid is multiplied by the ligand score for that grid.</span></span><br><span class="line"><span class="string">  &lt;/SCORINGGRIDS&gt;</span></span><br><span class="line"><span class="string">  &lt;LIGAND_AREAS&gt;</span></span><br><span class="line"><span class="string">    &lt;LigandArea name=&quot;docking_sidechain_X&quot; chain=&quot;X&quot; cutoff=&quot;6.0&quot; add_nbr_radius=&quot;true&quot; all_atom_mode=&quot;true&quot; minimize_ligand=&quot;10&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;LigandArea name=&quot;final_sidechain_X&quot; chain=&quot;X&quot; cutoff=&quot;6.0&quot; add_nbr_radius=&quot;true&quot; all_atom_mode=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;LigandArea name=&quot;final_backbone_X&quot; chain=&quot;X&quot; cutoff=&quot;7.0&quot; add_nbr_radius=&quot;false&quot; all_atom_mode=&quot;true&quot; Calpha_restraints=&quot;0.3&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/LIGAND_AREAS&gt;</span></span><br><span class="line"><span class="string">  &lt;INTERFACE_BUILDERS&gt;</span></span><br><span class="line"><span class="string">    &lt;InterfaceBuilder name=&quot;side_chain_for_docking&quot; ligand_areas=&quot;docking_sidechain_X&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;InterfaceBuilder name=&quot;side_chain_for_final&quot; ligand_areas=&quot;final_sidechain_X&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;InterfaceBuilder name=&quot;backbone&quot; ligand_areas=&quot;final_backbone_X&quot; extension_window=&quot;3&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/INTERFACE_BUILDERS&gt;</span></span><br><span class="line"><span class="string">  &lt;MOVEMAP_BUILDERS&gt;</span></span><br><span class="line"><span class="string">    &lt;MoveMapBuilder name=&quot;docking&quot; sc_interface=&quot;side_chain_for_docking&quot; minimize_water=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;MoveMapBuilder name=&quot;final&quot; sc_interface=&quot;side_chain_for_final&quot; bb_interface=&quot;backbone&quot; minimize_water=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/MOVEMAP_BUILDERS&gt;</span></span><br><span class="line"><span class="string">  &lt;MOVERS&gt;</span></span><br><span class="line"><span class="string">    &lt;SavePoseMover name=&quot;spm&quot; restore_pose=&quot;0&quot; reference_name=&quot;store_native&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Transform name=&quot;transform&quot; chain=&quot;X&quot; box_size=&quot;20.0&quot; move_distance=&quot;10&quot; angle=&quot;360&quot; initial_perturb=&quot;2&quot; cycles=&quot;500&quot; repeats=&quot;5&quot; temperature=&quot;1000&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;HighResDocker name=&quot;high_res_docker&quot; cycles=&quot;9&quot; repack_every_Nth=&quot;3&quot; scorefxn=&quot;fa_standard&quot; movemap_builder=&quot;docking&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;FinalMinimizer name=&quot;final&quot; scorefxn=&quot;fa_standard&quot; movemap_builder=&quot;final&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/MOVERS&gt;</span></span><br><span class="line"><span class="string">  &lt;FILTERS&gt;</span></span><br><span class="line"><span class="string">      &lt;LigInterfaceEnergy name=&quot;interfE&quot; scorefxn=&quot;fa_standard&quot; energy_cutoff=&quot;0.0&quot; confidence=&quot;0&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;SimpleMetricFilter name=&quot;rmsd_chX&quot; metric=&quot;rmsd_chX&quot; cutoff=&quot;999999.&quot; comparison_type=&quot;lt&quot; confidence=&quot;0&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/FILTERS&gt;</span></span><br><span class="line"><span class="string">  &lt;PROTOCOLS&gt;</span></span><br><span class="line"><span class="string">    &lt;Add mover=&quot;spm&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Add mover=&quot;transform&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Add mover=&quot;high_res_docker&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Add mover=&quot;final&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Add filter=&quot;interfE&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;Add filter=&quot;rmsd_chX&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/PROTOCOLS&gt;</span></span><br><span class="line"><span class="string">&lt;/ROSETTASCRIPTS&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>).get_mover(<span class="string">&quot;ParsedProtocol&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (16) Job Distributor</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(16)%20Job%20Distributor/</url>
    <content><![CDATA[<h1 id="PyRosetta-16-Job-Distributor"><a href="#PyRosetta-16-Job-Distributor" class="headerlink" title="PyRosetta (16) Job Distributor"></a>PyRosetta (16) Job Distributor</h1><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Instantiation of a `PyJobDistributor` object</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output file name prefix: &quot;output&quot;</span></span><br><span class="line"><span class="string">Job numbers: 10</span></span><br><span class="line"><span class="string">Job evaluation: my_scorefxn</span></span><br><span class="line"><span class="string">Notice: a file called `output.fasc` will also be generated. It summarizes the energies and RMSDs of all structures created.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">jd = PyJobDistributor(<span class="string">&quot;output&quot;</span>, <span class="number">10</span>, my_scorefxn, compress=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Set native_pose</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Assume that we have a `Pose` object called `my_starting_pose`</span></span><br><span class="line"><span class="string">`my_starting_pose` is the native crystal structure</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">jd.native_pose = my_starting_pose</span><br><span class="line"></span><br><span class="line"><span class="comment">## We can manually run a job</span></span><br><span class="line">my_pose.assign(my_starting_pose)</span><br><span class="line">my_mover.apply(my_pose)</span><br><span class="line">jd.output_decoy(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Or, we can loop until all jobs are completed</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> jd.job_complete:</span><br><span class="line">    my_pose.assign(my_starting_pose)</span><br><span class="line">    my_mover.apply(my_pose)</span><br><span class="line">    jd.output_decoy(my_pose)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (2) PyMOL Mover</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(2)%20PyMOL%20Mover/</url>
    <content><![CDATA[<h1 id="PyRosetta-2-PyMOL-Mover"><a href="#PyRosetta-2-PyMOL-Mover" class="headerlink" title="PyRosetta (2): PyMOL Mover"></a>PyRosetta (2): PyMOL Mover</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.moves <span class="keyword">import</span> PyMOLMover</span><br><span class="line">init()</span><br><span class="line"><span class="comment">#import pyrosetta</span></span><br><span class="line"><span class="comment">#pyrosetta.init()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose = pose_from_pdb(<span class="string">&quot;inputs/5tj3.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><a href="https://www.pyrosetta.org/documentation/pymol_mover-tutorial">https://www.pyrosetta.org/documentation/pymol_mover-tutorial</a></p>
<h2 id="PyMOLMover-class"><a href="#PyMOLMover-class" class="headerlink" title="PyMOLMover class"></a><code>PyMOLMover</code> class</h2><p>The <code>pyrosetta.rosetta.protocols.moves.PyMOLMover</code> class will let us send information from PyRosetta to PyMOL for quick visualization. </p>
<h3 id="Setup-PyMOL"><a href="#Setup-PyMOL" class="headerlink" title="Setup PyMOL"></a>Setup PyMOL</h3><h4 id="Get-Configuration-file-PyMOLPyRosettaServer-py-in-Linux"><a href="#Get-Configuration-file-PyMOLPyRosettaServer-py-in-Linux" class="headerlink" title="Get Configuration file: PyMOLPyRosettaServer.py(in Linux)"></a>Get Configuration file: <code>PyMOLPyRosettaServer.py</code>(in Linux)</h4><p><code>PyMOLPyRosettaServer.py</code> is found in the main directory of PyRosetta.</p>
<p>The path to PyRosetta can be discovered in the init information.</p>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Requirement already satisfied: pyrosettacolabsetup <span class="keyword">in</span> /home/michael2003/anaconda3/envs/DESIGN_PROTEIN/lib/python3.9/site-packages (1.0.9)</span><br><span class="line">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                 PyRosetta-4                                  │</span><br><span class="line">│              Created <span class="keyword">in</span> JHU by Sergey Lyskov and PyRosetta Team              │</span><br><span class="line">│              (C) Copyright Rosetta Commons Member Institutions               │</span><br><span class="line">│                                                                              │</span><br><span class="line">│ NOTE: USE OF PyRosetta FOR COMMERCIAL PURPOSES REQUIRE PURCHASE OF A LICENSE │</span><br><span class="line">│         See LICENSE.PyRosetta.md or email license@uw.edu <span class="keyword">for</span> details         │</span><br><span class="line">└──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">PyRosetta-4 2025 [Rosetta PyRosetta4.conda.ubuntu.cxx11thread.serialization.Ubuntu.python39.Release 2025.24+release.8e1e5e54f047b0833dcf760a5cd5d3ce94d63938 2025-06-06T09:20:57] retrieved from: http://www.pyrosetta.org</span><br><span class="line">core.init: Checking <span class="keyword">for</span> fconfig files <span class="keyword">in</span> <span class="built_in">pwd</span> and ./rosetta/flags</span><br><span class="line">core.init: Rosetta version: PyRosetta4.conda.ubuntu.cxx11thread.serialization.Ubuntu.python39.Release r403 2025.24+release.8e1e5e54f0 8e1e5e54f047b0833dcf760a5cd5d3ce94d63938 http://www.pyrosetta.org 2025-06-06T09:20:57</span><br><span class="line">core.init: Rosetta extras: [cxx11thread, serialization]</span><br><span class="line">core.init: <span class="built_in">command</span>: PyRosetta -ex1 -ex2aro -database /home/michael2003/anaconda3/envs/DESIGN_PROTEIN/lib/python3.9/site-packages/pyrosetta/database</span><br><span class="line">basic.random.init_random_generator: <span class="string">&#x27;RNG device&#x27;</span> seed mode, using <span class="string">&#x27;/dev/urandom&#x27;</span>, seed=-481462242 seed_offset=0 real_seed=-481462242 thread_index=0</span><br><span class="line">basic.random.init_random_generator: RandomGenerator:init: Normal mode, seed=-481462242 RG_type=mt19937</span><br></pre></td></tr></table></figure>

<p>In this example, path to PyRosetta is:</p>
<p><code>/home/michael2003/anaconda3/envs/DESIGN_PROTEIN/lib/python3.9/site-packages/pyrosetta/</code></p>
<h4 id="Copy-edit-the-configuration-file-in-Windows"><a href="#Copy-edit-the-configuration-file-in-Windows" class="headerlink" title="Copy &amp; edit the configuration file (in Windows)"></a>Copy &amp; edit the configuration file (in Windows)</h4><p>I’m using PyMOL on Windows, and PyRosetta on WSL Ubuntu.</p>
<p>Therefore, I have to edit the <code>PyMOLPyRosettaServer.py</code> file to appoint a correct IP address.</p>
<p><a href="https://learn.microsoft.com/en-us/windows/wsl/networking">https://learn.microsoft.com/en-us/windows/wsl/networking</a></p>
<blockquote>
<p>A program running inside a Linux distribution via WSL2 (instance) wants to know the Windows host’s IP address, so that a Linux program can connect to a Windows host server program.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route show | grep -i default | awk <span class="string">&#x27;&#123; print $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>And a typical output might look like:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">172.24</span>.<span class="number">112.1</span></span><br></pre></td></tr></table></figure>

<p>Copy the PyMOLPyRosettaServer.py from Linux to Windows (to D:).</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> &lt;Path-to-PyRosetta&gt;/PyMOLPyRosettaServer.py /mnt/d/</span><br></pre></td></tr></table></figure>

<p>And edit the file according to the comments within it. (The IP configuration is in the last few lines.) Appoint the right remote IP, and appoint an available port (e.g. <code>65000</code>).</p>
<h4 id="Apply-the-PyMOLPyRosettaServer-py-to-PyMOL-in-Windows"><a href="#Apply-the-PyMOLPyRosettaServer-py-to-PyMOL-in-Windows" class="headerlink" title="Apply the PyMOLPyRosettaServer.py  to PyMOL (in Windows)"></a>Apply the PyMOLPyRosettaServer.py  to PyMOL (in Windows)</h4><p>a. Drag the file to PyMOL window.</p>
<p>b. Or, run the following commands in the PyMOL command line.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D: <span class="comment">#Because I save PyMOLRosettaServer.py there.</span></span><br><span class="line">run PyMOLRosettaServer.py</span><br></pre></td></tr></table></figure>

<p>c. Or, save the commands above to <code>pymolrc.pml</code>; thus it runs automatically each time pyMOL launches<br>(The <code>pymolrc.pml</code>file can be found from GUI menu: <code>File</code> &gt;&gt; <code>Edit pymolrc</code>)</p>
<h3 id="Instantiation-of-PyMOLMover"><a href="#Instantiation-of-PyMOLMover" class="headerlink" title="Instantiation of PyMOLMover"></a>Instantiation of <code>PyMOLMover</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pmm = PyMOLMover(<span class="string">&quot;172.24.112.1&quot;</span>, <span class="number">65000</span>)</span><br></pre></td></tr></table></figure>



<h3 id="PyMOLMovermethods"><a href="#PyMOLMovermethods" class="headerlink" title="PyMOLMovermethods"></a><code>PyMOLMover</code>methods</h3><h4 id="Keep-history"><a href="#Keep-history" class="headerlink" title="Keep history"></a>Keep history</h4><p>The method <code>keep_history</code>, if set to True, allows you to load in structures with the same name into states of the same object in PyMOL. </p>
<p>This is the starting point for creating a PyMOL movie of your structure.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pmm.keep_history(<span class="literal">True</span>) <span class="comment"># This keeps history of all poses sent to PyMOL</span></span><br></pre></td></tr></table></figure>

<h4 id="Send-a-pose-object-to-PyMOL"><a href="#Send-a-pose-object-to-PyMOL" class="headerlink" title="Send a pose object to PyMOL"></a>Send a <code>pose</code> object to PyMOL</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pmm.apply(my_pose)</span><br><span class="line"><span class="comment"># After running this, my_pose is expected to show up in the PyMOL window</span></span><br></pre></td></tr></table></figure>

<p>See <code>AddPyMOLObserver</code>class for information about automatic updating the <em>pose</em> during <em>move.</em></p>
<h4 id="Send-energy-energy-across-every-residue-of-a-poseobject-to-PyMOL"><a href="#Send-energy-energy-across-every-residue-of-a-poseobject-to-PyMOL" class="headerlink" title="Send energy (energy across every residue) of a poseobject to PyMOL"></a>Send energy (energy across every residue) of a <code>pose</code>object to PyMOL</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assume that `pmm` is an instance of `PyMOLMover`</span></span><br><span class="line"><span class="comment"># assume that `my_pose` is an instance of `Pose`</span></span><br><span class="line">pmm.send_energy(my_pose) <span class="comment"># visualize the distribution of energy across the structure</span></span><br><span class="line">pmm.send_energy(my_pose, fa_sol) <span class="comment"># visualize the distribution of solvation energy (of full atom energy landscape) across the structure</span></span><br></pre></td></tr></table></figure>

<h4 id="Send-properties-of-the-poseobject-to-PyMOL"><a href="#Send-properties-of-the-poseobject-to-PyMOL" class="headerlink" title="Send properties of the poseobject to PyMOL"></a>Send properties of the <code>pose</code>object to PyMOL</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if you have scored the pose first, you can:</span></span><br><span class="line">pmm.send_hbonds(my_pose) <span class="comment">#show all hydrogen bonds in PyMOL</span></span><br></pre></td></tr></table></figure>

<h2 id="AddPyMOLObserver-class"><a href="#AddPyMOLObserver-class" class="headerlink" title="AddPyMOLObserver class"></a><code>AddPyMOLObserver</code> class</h2><p>The observer is configured to execute a <code>PyMOLMover.apply()</code> every time a change is observed in the pose coordinates. The <code>True</code> is a flag to ensure that PyMOL keeps a history of the moves.</p>
<p>The observer should be added before executing the move(s).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">observer = pyrosetta.rosetta.protocols.moves.AddPyMOLObserver(my_pose, <span class="literal">True</span>)</span><br><span class="line">my_mover.apply(my_pose)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (3) Viewer</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(3)%20Viewer/</url>
    <content><![CDATA[<h1 id="PyRosetta-3-Viewer"><a href="#PyRosetta-3-Viewer" class="headerlink" title="PyRosetta (3): Viewer"></a>PyRosetta (3): Viewer</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The pyrosetta.distributed Viewer quickly renders <code>.pdb</code> files, dynamically instantiating Pose objects if required for certain visualization modules (<code>viewer.set*</code>). </p>
<p>So when adding visualization modules to the Viewer or using presets, passing Pose or PackedPose objects to the Viewer is suggested for quicker rendering. </p>
<p>If a Pose object or list, tuple, or set of Pose objects are provided to the Viewer, the Viewer will dynamically update upon Pose conformational changes by calling the view.show() method or equivalently view(). </p>
<p>The Viewer applies visualization modules in the same order they are added (from left to right), so layering different styles (and <code>ResidueSelectors</code>) on top of one another becomes possible. </p>
<p>WARNING: <code>pyrosetta.distributed.viewer</code>runs in a Jupyter notebook.</p>
<h2 id="Initialization-load"><a href="#Initialization-load" class="headerlink" title="Initialization &amp; load"></a>Initialization &amp; load</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install pyrosettacolabsetup</span><br><span class="line"><span class="keyword">import</span> pyrosettacolabsetup; pyrosettacolabsetup.install_pyrosetta()</span><br><span class="line"><span class="keyword">import</span> pyrosetta; </span><br><span class="line">pyrosetta.init()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyrosetta</span><br><span class="line"><span class="keyword">import</span> pyrosetta.distributed</span><br><span class="line"><span class="keyword">import</span> pyrosetta.distributed.io <span class="keyword">as</span> io</span><br><span class="line"><span class="keyword">import</span> pyrosetta.distributed.viewer <span class="keyword">as</span> viewer</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose = pyrosetta.io.pose_from_file(<span class="string">&quot;inputs/3EK4.pdb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Configuring-ditributedfor-visualizing-ligands-and-non-canonical-residues"><a href="#Configuring-ditributedfor-visualizing-ligands-and-non-canonical-residues" class="headerlink" title="Configuring ditributedfor visualizing ligands and non-canonical residues"></a>Configuring <code>ditributed</code>for visualizing ligands and non-canonical residues</h2><p>The user must have already initialized PyRosetta providing <code>.params</code> for any ligands and non-canonical residues in the input <code>Pose</code>objects &#x2F;<code>PackedPose</code>objects&#x2F;<code>.pdb</code> files.</p>
<p>Otherwise <code>pyrosetta.distributed</code> automatically initializes PyRosetta with default command line options.</p>
<p>E.g.:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flags = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">-auto_setup_metals 1</span></span><br><span class="line"><span class="string">-detect_disulf 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Display metal: True</span></span><br><span class="line"><span class="comment"># Display disulfide bonds: True</span></span><br><span class="line">pyrosetta.distributed.init(flags)</span><br></pre></td></tr></table></figure>

<h2 id="Instantiation-of-distributed-viewer"><a href="#Instantiation-of-distributed-viewer" class="headerlink" title="Instantiation of distributed.viewer"></a>Instantiation of <code>distributed.viewer</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">view = viewer.init(pose, window_size=(<span class="number">800</span>, <span class="number">600</span>))</span><br><span class="line">view()</span><br></pre></td></tr></table></figure>

<h2 id="distributed-viewer-methods"><a href="#distributed-viewer-methods" class="headerlink" title="distributed.viewer methods"></a><code>distributed.viewer</code> methods</h2><p>The <code>pyrosetta.distributed</code> Viewer quickly renders <code>.pdb</code> files, dynamically instantiating Pose objects if required for certain visualization modules (<code>viewer.set*</code>). </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># All Available `viewer` objects:</span></span><br><span class="line">viewer.__all__</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">[&#x27;expand_notebook&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;init&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;presets&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setBackgroundColor&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setDisulfides&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setHydrogenBonds&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setHydrogens&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setStyle&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setSurface&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setZoom&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;setZoomTo&#x27;]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>visualization modules: <code>viewer.set*</code></li>
<li>visualization presets: <code>viewer.presets</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">viewer.presets.__all__</span><br><span class="line"><span class="comment"># &gt;&gt;&gt; [&#x27;coreBoundarySurface&#x27;, &#x27;ligandsAndMetals&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>pyrosetta.distributed.viewer.expand_notebook()</code> expands the Jupyter notebook cell width to fit your internet browser</li>
</ol>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (4) Rosetta Scripts Parser</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(4)%20Rosetta%20Scripts%20Parser/</url>
    <content><![CDATA[<h1 id="PyRosetta-4-Rosetta-Scripts-Parser"><a href="#PyRosetta-4-Rosetta-Scripts-Parser" class="headerlink" title="PyRosetta (4): Rosetta Scripts Parser"></a>PyRosetta (4): Rosetta Scripts Parser</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install pyrosettacolabsetup</span><br><span class="line"><span class="keyword">import</span> pyrosettacolabsetup; pyrosettacolabsetup.install_pyrosetta()</span><br><span class="line"><span class="keyword">import</span> pyrosetta; pyrosetta.init()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> rosetta.protocols.rosetta_scripts <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init(<span class="string">&#x27;-no_fconfig @inputs/rabd/common&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><code>rosetta.protocols.rosetta_scripts.RosettaScriptsParser</code> parses a Rosetta Script so that it can be called in PyRosetta.</p>
<p>Rosetta Scripts are in XML format.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ROSETTASCRIPTS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SCOREFXNS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SCOREFXNS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RESIDUE_SELECTORS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RESIDUE_SELECTORS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TASKOPERATIONS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TASKOPERATIONS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SIMPLE_METRICS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SIMPLE_METRICS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FILTERS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FILTERS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MOVERS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">MOVERS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PROTOCOLS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PROTOCOLS</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OUTPUT</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ROSETTASCRIPTS</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Rosetta will carry out the order of operations specified in <code>&lt;PROTOCOLS&gt;&lt;/PROTOCOLS&gt;</code>. </p>
<p>SimpleMetrics (<code>&lt;SIMPLE_METRICS&gt;&lt;/SIMPLE_METRICS&gt;</code>) and Filters (<code>&lt;FILTERS&gt;&lt;/FILTERS&gt;</code>) do not change the sequence or conformation of the structure.</p>
<p>The movers (<code>&lt;MOVERS&gt;&lt;/MOVERS&gt;</code>) do change the pose, and the output file will be the result of sequentially applying the movers in the protocols section. </p>
<p>The standard scores of the output will be carried over from any protocol doing scoring, unless the OUTPUT tag (<code>&lt;OUTPUT&gt;&lt;/OUTPUT&gt;</code>) is specified, in which case the corresponding score function from the <code>&lt;SCOREFXNS&gt;&lt;/SCOREFXNS&gt;</code> block will be used. </p>
<h2 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_parser = RosettaScriptsParser()</span><br><span class="line"><span class="comment"># my_parser is an instanse of `RosettaScriptsParser`</span></span><br><span class="line">my_pose = pose_from_pdb(<span class="string">&quot;inputs/rabd/my_ab.pdb&quot;</span>)</span><br><span class="line"><span class="comment"># my_pose is an instance of `Pose`; it is generated by calling `pyrosetta.pose_from_pdb`</span></span><br><span class="line">my_pose_clone = my_pose.clone()</span><br><span class="line"><span class="comment"># Always clone a copy as an archive before editing</span></span><br></pre></td></tr></table></figure>

<h2 id="Load-a-protocol"><a href="#Load-a-protocol" class="headerlink" title="Load a protocol"></a>Load a protocol</h2><h3 id="Load-from-file"><a href="#Load-from-file" class="headerlink" title="Load from file"></a>Load from file</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load from file</span></span><br><span class="line">my_protocol = parser.generate_mover(<span class="string">&quot;inputs/min_L1.xml&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Load-from-string-construct-a-XML-object"><a href="#Load-from-string-construct-a-XML-object" class="headerlink" title="Load from string (construct a XML object)"></a>Load from string (construct a <code>XML</code> object)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_L1 = <span class="string">&quot;&lt;ROSETTASCRIPTS&gt;...&lt;/ROSETTASCRIPTS&gt;&quot;</span> <span class="comment"># min_L1 is a string that is in XML format</span></span><br><span class="line">xml = XmlObjects.create_from_string(min_L1)</span><br><span class="line">my_protocol = xml.get_mover(<span class="string">&quot;ParsedProtocol&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Apply-a-protocol"><a href="#Apply-a-protocol" class="headerlink" title="Apply a protocol"></a>Apply a protocol</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_protocol.apply(my_pose)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (6) Movers for Backbone Folding</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(6)%20Backbone%20Folding/</url>
    <content><![CDATA[<h1 id="PyRosetta-6-Movers-for-Backbone-Folding"><a href="#PyRosetta-6-Movers-for-Backbone-Folding" class="headerlink" title="PyRosetta (6): Movers for Backbone Folding"></a>PyRosetta (6): Movers for Backbone Folding</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install pyrosettacolabsetup</span><br><span class="line"><span class="keyword">import</span> pyrosettacolabsetup; pyrosettacolabsetup.install_pyrosetta()</span><br><span class="line"><span class="keyword">import</span> pyrosetta; pyrosetta.init()</span><br><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.teaching <span class="keyword">import</span> *</span><br><span class="line">init()</span><br></pre></td></tr></table></figure>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>One of the most basic operations in protein structure and design algorithms is manipulation of the protein conformation. </p>
<p>In Rosetta, these manipulations are organized into <code>mover(s)</code>. </p>
<p>A <code>Mover</code> object simply changes the conformation of a given pose. </p>
<p>It can be simple, like a single φ or ψ angle change, or complex, like an entire refinement protocol.</p>
<p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/Movers-RosettaScripts">Movers(RosettaScripts)</a></p>
<h2 id="MoveMap-class"><a href="#MoveMap-class" class="headerlink" title="MoveMap class"></a><code>MoveMap</code> class</h2><p>Most <code>Movers</code> require a <code>MoveMap</code> object to specify which degrees of freedom are fixed and which are free to change.</p>
<p><code>pyrosetta.rosetta.core.kinematics.MoveMap()</code></p>
<p>Example1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_movemap = MoveMap()</span><br><span class="line">my_movemap.set_bb(<span class="literal">True</span>) <span class="comment"># Allowing a mover to change the backbone structure</span></span><br></pre></td></tr></table></figure>

<p>Example2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">movemap.set_bb(<span class="literal">False</span>) <span class="comment"># Prohibit a mover to change the backbone structure</span></span><br><span class="line">movemap.set_bb(<span class="number">50</span>, <span class="literal">True</span>) <span class="comment"># Allow a mover to chage the backbone structure of residue #50</span></span><br><span class="line">movemap.set_bb(<span class="number">51</span>, <span class="literal">True</span>) <span class="comment"># Allow a mover to chage the backbone structure of residue #51</span></span><br><span class="line"><span class="comment"># Only the backbone structure at residue #50 and #51 can be modified by a mover</span></span><br></pre></td></tr></table></figure>

<h2 id="Basic-Backbone-Folding-Process"><a href="#Basic-Backbone-Folding-Process" class="headerlink" title="Basic Backbone Folding Process"></a>Basic Backbone Folding Process</h2><h3 id="Making-a-trial-move"><a href="#Making-a-trial-move" class="headerlink" title="Making a trial move"></a>Making a trial move</h3><p>Apply a <em>move</em> (change) to the <em>pose</em> (structure).</p>
<h3 id="Scoring-the-move"><a href="#Scoring-the-move" class="headerlink" title="Scoring the move"></a>Scoring the move</h3><p>Compare the energy scores before and after the move. </p>
<p>(Therefore, the pose should be cloned as a backup before the move.)</p>
<p>And, compare the energy score after the <em>move</em> and the lowest energy score in history. </p>
<p>If the score after this <em>move</em> is the lowest, store the _pose <em>after this</em> move _as the best pose, and renew the lowest energy score in history.</p>
<h3 id="Deciding-whether-or-not-to-accept-the-move"><a href="#Deciding-whether-or-not-to-accept-the-move" class="headerlink" title="Deciding whether or not to accept the move"></a>Deciding whether or not to accept the move</h3><p>For the decision step, we need to make a subroutine that either accepts or rejects the new conformation based on the Metropolis criterion. </p>
<p>The difference between the energy scores after (t+1) and before (t) a move is $ \Delta E &#x3D; E_{t+1} - E_{t} $.</p>
<p>The Metropolis criterion has a probability of accepting a move as $ P &#x3D; \exp( -\Delta E &#x2F; kT ) $.</p>
<p>When $ ΔE ≥ 0 $, the Metropolis criterion probability of accepting the move is $ P &#x3D; \exp( -\Delta E &#x2F; kT ) $.</p>
<p>When $ ΔE &lt; 0 $, the Metropolis criterion probability of accepting the move is $ P &#x3D; 1 $. </p>
<p>Use $ kT &#x3D; 1 \text{\ Rosetta \ Energy \ Unit \ (REU)} $ . </p>
<p>NOTICE: Search “Boltzmann function” and “Simulated annealing” for more information about $ kT $.</p>
<p>If the move is accepted, the <em>pose</em> after the <em>move</em> will be used for the next round of trial <em>move.</em></p>
<p>If not, the <em>pose</em> before the _move _will be used for the next round of trial <em>move</em>.</p>
<h3 id="Iterations"><a href="#Iterations" class="headerlink" title="Iterations"></a>Iterations</h3><p>For each iteration, the 3 steps above are executed. </p>
<p>The final output of this program should be the <strong>lowest energy conformation</strong> that is achieved <strong>at any point</strong> during the simulation. </p>
<p>NOTICE: Search “greedy algorithm” and “Monte Carlo” for more information about the algorithm design. </p>
<h2 id="Basic-backbone-movers"><a href="#Basic-backbone-movers" class="headerlink" title="Basic backbone movers"></a>Basic backbone movers</h2><h3 id="SmallMover-ShearMover-classes"><a href="#SmallMover-ShearMover-classes" class="headerlink" title="SmallMover &amp; ShearMover classes"></a><code>SmallMover</code> &amp; <code>ShearMover</code> classes</h3><table>
<thead>
<tr>
<th><strong>Mover</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>SmallMover</code></td>
<td>Makes “small-move-style” torsion moves (no propagation minimization)</td>
</tr>
<tr>
<td><code>ShearMover</code></td>
<td>Makes “shear-style” torsion moves that <strong>minimize downstream propagation</strong></td>
</tr>
</tbody></table>
<p>For convenience, the <code>SmallMover</code> and <code>ShearMover</code> can do multiple rounds of perturbation. </p>
<p>They also check that the new φ&#x2F;ψ combinations are within an allowable region of the <strong>Ramachandran plot</strong> by using a <strong>Metropolis acceptance criterion</strong> based on the rama score component change. (The <code>rama</code> score is a statistical score from Simons et al. 1999, parametrized by bins of φ&#x2F;ψ space.) </p>
<p>Because they use the Metropolis criterion, we must also supply <code>kT</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kT = <span class="number">1.0</span> <span class="comment"># temperature</span></span><br><span class="line">n_moves = <span class="number">1</span> <span class="comment"># iterations</span></span><br><span class="line"></span><br><span class="line">movemap = MoveMap()</span><br><span class="line">movemap.set_bb(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">small_mover = SmallMover(movemap, kT, n_moves)</span><br><span class="line">shear_mover = ShearMover(movemap, kT, n_moves)</span><br></pre></td></tr></table></figure>

<h3 id="BackrubMover"><a href="#BackrubMover" class="headerlink" title="BackrubMover"></a><code>BackrubMover</code></h3><table>
<thead>
<tr>
<th><strong>Mover</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BackrubMover</td>
<td>Makes local rotations around two backbone atoms</td>
</tr>
</tbody></table>
<h3 id="Minimization-Mover-MinMoverclass"><a href="#Minimization-Mover-MinMoverclass" class="headerlink" title="Minimization Mover MinMoverclass"></a>Minimization Mover <code>MinMover</code>class</h3><p>The <code>MinMover</code> carries out a <strong>gradient-based</strong> minimization to find the <strong>nearest local minimum</strong> in the energy function, such as that used in one step of the Monte-Carlo-plus-Minimization algorithm of Li &amp; Scheraga. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_mover = MinMover()</span><br></pre></td></tr></table></figure>

<h2 id="MonteCarlo-class"><a href="#MonteCarlo-class" class="headerlink" title="MonteCarlo class"></a><code>MonteCarlo</code> class</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>The <code>MonteCarlo</code> object is an encapsulated object that creates a whole <code>MonteCarlo</code> simulation.</p>
<p>That is, it can decide whether to accept or reject a trial conformation, and it keeps track of the lowest-energy conformation and other statistics about the search.</p>
<p>Having the Monte Carlo operations packaged together is convenient, especially if we want multiple Monte Carlo loops to nest within each other or to operate on different parts of the protein.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have instantiated a mover `my_mover`</span></span><br><span class="line"><span class="comment"># Instantiate a `MonteCarlo` object `mc`</span></span><br><span class="line">mc = MonteCarlo(my_pose, scorefxn, kT)</span><br><span class="line"><span class="comment"># my_pose: a Pose object</span></span><br><span class="line"><span class="comment"># scorefxn: a ScoreFunction object</span></span><br><span class="line"><span class="comment"># kT: a parameter - temperature; int or float </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># apply the mover</span></span><br><span class="line">my_mover.apply(my_pose) </span><br><span class="line"></span><br><span class="line"><span class="comment"># deside whether or not to accept the move</span></span><br><span class="line">flag = mc.boltzmann(my_pose)</span><br><span class="line"><span class="comment"># flag is boolean</span></span><br><span class="line"><span class="comment"># True: accept</span></span><br><span class="line"><span class="comment"># False: reject</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In practice, these 3 steps should be written into a loop.</span></span><br></pre></td></tr></table></figure>



<p>A Monte Carlo Simulation process is (in pseudo code):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_sampling</span>(<span class="params">initial_state, kT, N_iteration</span>):</span><br><span class="line">    current_state = initial state</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N_iteration):</span><br><span class="line">        new_state = random_move(current_state)</span><br><span class="line">        <span class="comment">#fe_delta: delta (difference of) free energies</span></span><br><span class="line">        fe_delta = free_energy(new_state)-free_energy(current_state) </span><br><span class="line">        <span class="keyword">if</span> fe_delta &lt; <span class="number">0</span> <span class="keyword">or</span> uniform(<span class="number">1</span>) &lt; exp(-fe_delta / kT): </span><br><span class="line">            <span class="comment"># exp(-fe_delta / kT): boltzmann distribution</span></span><br><span class="line">            current_state = new_state</span><br></pre></td></tr></table></figure>

<h3 id="MonteCarlo-Methods"><a href="#MonteCarlo-Methods" class="headerlink" title="MonteCarlo Methods"></a><code>MonteCarlo</code> Methods</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mc.boltzmann(my_pose) <span class="comment"># See above</span></span><br><span class="line">mc.show_scores()</span><br><span class="line">mc.show_counters()</span><br><span class="line">mc.show_state()</span><br></pre></td></tr></table></figure>

<h3 id="TrialMoverclass"><a href="#TrialMoverclass" class="headerlink" title="TrialMoverclass"></a><code>TrialMover</code>class</h3><p>A <code>TrialMover</code> combines a specified <code>Mover</code> with a <code>MonteCarlo</code> object.</p>
<p>Each time a <code>TrialMover</code> is called, it performs a trial move and tests that move’ s acceptance with the &#96;MonteCarlo object.</p>
<p>It is designed to test the effects of a <code>Mover</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trial_mover = TrialMover(small_mover, mc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    trial_mover.apply(test)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(trial_mover.num_accepts())</span><br><span class="line"><span class="built_in">print</span>(trial_mover.acceptance_rate())</span><br><span class="line"></span><br><span class="line"><span class="comment"># After the trial, information about the trial can also be visited by</span></span><br><span class="line"><span class="comment"># mc.show_state()</span></span><br><span class="line"><span class="comment"># so that different movers can be compared</span></span><br></pre></td></tr></table></figure>



<h2 id="SequenceMoverclass-and-RepeatMoverclass"><a href="#SequenceMoverclass-and-RepeatMoverclass" class="headerlink" title="SequenceMoverclass and RepeatMoverclass"></a><code>SequenceMover</code>class and <code>RepeatMover</code>class</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq_mover = SequenceMover()</span><br><span class="line">seq_mover.add_mover(small_mover)</span><br><span class="line">seq_mover.add_mover(shear_mover)</span><br><span class="line">seq_mover.add_mover(min_mover)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_repeats = <span class="number">3</span></span><br><span class="line">repeat_mover = RepeatMover(my_mover, n_repeats)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (5) Score Function</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(5)%20Score%20Function/</url>
    <content><![CDATA[<h1 id="PyRosetta-5-Score-Function"><a href="#PyRosetta-5-Score-Function" class="headerlink" title="PyRosetta (5): Score Function"></a>PyRosetta (5): Score Function</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install pyrosettacolabsetup</span><br><span class="line"><span class="keyword">import</span> pyrosettacolabsetup; pyrosettacolabsetup.install_pyrosetta()</span><br><span class="line"><span class="keyword">import</span> pyrosetta; pyrosetta.init()</span><br><span class="line"><span class="keyword">import</span> pyrosetta</span><br><span class="line">pyrosetta.init()</span><br></pre></td></tr></table></figure>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Rosetta scores the energy of a <code>pose</code>object with a score function.</p>
<p>The lower the enegy, the more stable the pose.</p>
<p>The score function is an object of <code>pyrosetta.ScoreFunction</code> class.</p>
<p>The total score is a sum of per-residue score.</p>
<p>The unweighted value of energy terms (of each residue) is stored in the <code>pose</code>object, and can be visited via <code>Pose.energies</code>method. (See <a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/ktcfk65y26wfqciw">Note | PyRosetta Basics (1): Pose</a>)</p>
<p>The score function stores a series of weights correspond to each energy term, and calculate the total score.</p>
<p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/score-types">Energy Terms In Rosetta</a></p>
<p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/centroid-score-terms">Centroid score terms and score functions in Rosetta</a></p>
<p><a href="https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.scoring.html">Scoring PyRosetta 4.0 document</a></p>
<h2 id="Instantiation-of-ScoreFunction"><a href="#Instantiation-of-ScoreFunction" class="headerlink" title="Instantiation of ScoreFunction"></a>Instantiation of <code>ScoreFunction</code></h2><p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/centroid-score-terms">Centroid score terms and score functions in Rosetta</a></p>
<h3 id="Empty-score-function"><a href="#Empty-score-function" class="headerlink" title="Empty score function"></a>Empty score function</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sfxn = ScoreFunction() <span class="comment">#sfxn is an empty `score_function` object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># and we can manually set the weights</span></span><br><span class="line">sfxn.set_weight(fa_atr, <span class="number">1.0</span>) </span><br><span class="line">sfxn.set_weight(fa_rep, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="teaching-get-score-functionmethod"><a href="#teaching-get-score-functionmethod" class="headerlink" title="teaching.get_score_functionmethod"></a><code>teaching.get_score_function</code>method</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.teaching <span class="keyword">import</span> *</span><br><span class="line">sfxn = get_score_function(<span class="literal">True</span>) </span><br><span class="line"><span class="comment"># get_score_function(is_fullatom: bool) in pyrosetta.teaching namespace</span></span><br><span class="line"><span class="comment"># True: default ref2015 all-atom energy function</span></span><br><span class="line"><span class="comment"># False: default centroid score function</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cen_sfxn = pyrosetta.create_score_function(<span class="string">&quot;score0&quot;</span>) </span><br><span class="line"><span class="comment"># a centroid score function</span></span><br><span class="line"><span class="comment"># score function used in the first stage of the ClassicAbInitio protocol</span></span><br><span class="line"><span class="comment"># https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/centroid-score-terms</span></span><br></pre></td></tr></table></figure>

<h3 id="get-fa-scorefxnmethod-the-default-ref2015-function"><a href="#get-fa-scorefxnmethod-the-default-ref2015-function" class="headerlink" title="get_fa_scorefxnmethod (the default ref2015 function)"></a><code>get_fa_scorefxn</code>method (the default ref2015 function)</h3><p>The <code>get_fa_scorefxn()</code> method is a wrapper of a method within <code>ScoreFunctionFactory</code> which returns the current standard <code>ScoreFunction</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scorefxn = get_fa_scorefxn()</span><br><span class="line">scorefxn(my_pose)</span><br></pre></td></tr></table></figure>

<h3 id="create-score-function-specify-a-weights-tag"><a href="#create-score-function-specify-a-weights-tag" class="headerlink" title="create_score_function(specify a weights_tag)"></a><code>create_score_function</code>(specify a <code>weights_tag</code>)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cart_sf = create_score_function(<span class="string">&quot;ref2015_cart&quot;</span>) <span class="comment"># Cartesian for Regional FastRelax</span></span><br></pre></td></tr></table></figure>

<h2 id="Score-a-pose"><a href="#Score-a-pose" class="headerlink" title="Score a pose"></a>Score a pose</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose = pyrosetta.pose_from_pdb(<span class="string">&quot;inputs/6Q21_A.pdb&quot;</span>) <span class="comment"># instantiate a `pose` object</span></span><br><span class="line">my_score = sfxn(my_pose)</span><br><span class="line"><span class="comment"># my_score is the total score; type is float</span></span><br></pre></td></tr></table></figure>

<h2 id="ScoreFunction-methods"><a href="#ScoreFunction-methods" class="headerlink" title="ScoreFunction methods"></a><code>ScoreFunction</code> methods</h2><h3 id="Show-energy-terms-in-detail"><a href="#Show-energy-terms-in-detail" class="headerlink" title="Show energy terms in detail"></a>Show energy terms in detail</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_sfxn.show(my_pose)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">core.scoring: </span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string"> Scores                       Weight   Raw Score Wghtd.Score</span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string"> fa_atr                       1.000   -1039.246   -1039.246</span></span><br><span class="line"><span class="string"> fa_rep                       0.550    1193.837     656.611</span></span><br><span class="line"><span class="string"> fa_sol                       1.000     682.582     682.582</span></span><br><span class="line"><span class="string"> fa_intra_rep                 0.005     700.419       3.502</span></span><br><span class="line"><span class="string"> fa_intra_sol_xover4          1.000      46.564      46.564</span></span><br><span class="line"><span class="string"> lk_ball_wtd                  1.000     -14.597     -14.597</span></span><br><span class="line"><span class="string"> fa_elec                      1.000    -195.387    -195.387</span></span><br><span class="line"><span class="string"> pro_close                    1.250      97.210     121.513</span></span><br><span class="line"><span class="string"> hbond_sr_bb                  1.000     -41.656     -41.656</span></span><br><span class="line"><span class="string"> hbond_lr_bb                  1.000     -28.352     -28.352</span></span><br><span class="line"><span class="string"> hbond_bb_sc                  1.000     -13.111     -13.111</span></span><br><span class="line"><span class="string"> hbond_sc                     1.000      -7.771      -7.771</span></span><br><span class="line"><span class="string"> dslf_fa13                    1.250       0.000       0.000</span></span><br><span class="line"><span class="string"> omega                        0.400      41.525      16.610</span></span><br><span class="line"><span class="string"> fa_dun                       0.700    1296.642     907.650</span></span><br><span class="line"><span class="string"> p_aa_pp                      0.600     -25.496     -15.298</span></span><br><span class="line"><span class="string"> yhh_planarity                0.625       0.000       0.000</span></span><br><span class="line"><span class="string"> ref                          1.000      47.114      47.114</span></span><br><span class="line"><span class="string"> rama_prepro                  0.450     197.781      89.002</span></span><br><span class="line"><span class="string">---------------------------------------------------</span></span><br><span class="line"><span class="string"> Total weighted score:                     1215.729</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Show-Intrinsic-weights-of-a-scoring-function"><a href="#Show-Intrinsic-weights-of-a-scoring-function" class="headerlink" title="Show Intrinsic weights of a scoring function"></a>Show Intrinsic weights of a scoring function</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scorefxn = get_fa_scorefxn() </span><br><span class="line"><span class="comment"># First create object by calling wrapped methods in `get_fa_scorefxn()`</span></span><br><span class="line">scorefxn.weights()[fa_atr]</span><br><span class="line"><span class="comment"># Then get data from the `scorefxn` object</span></span><br></pre></td></tr></table></figure>

<p>Or, use <code>ScoreFunction</code>class:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scorefxn = ScoreFunction()</span><br><span class="line"><span class="comment"># First create object by calling wrapped methods in `get_fa_scorefxn()`</span></span><br><span class="line">scorefxn.weights()[fa_atr]</span><br><span class="line"><span class="comment"># Then get data from the `scorefxn` object</span></span><br></pre></td></tr></table></figure>

<p>WARNING: The following usage is incorrect:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_fa_scorefxn().weights()[fa_atr] <span class="comment">#incorrect; returns 0.0</span></span><br></pre></td></tr></table></figure>

<p>Although the following lines do not cause mistakes, chain calling is a depreciated practice.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ScoreFunction().weights()[fa_atr]</span><br><span class="line"><span class="comment"># This creates an object `ScoreFunction`, </span></span><br><span class="line"><span class="comment">#  and then shows the default weight of the term `fa_atr`</span></span><br><span class="line"><span class="comment"># Works fine, but depreciated.</span></span><br></pre></td></tr></table></figure>

<h2 id="EMapVectorclass"><a href="#EMapVectorclass" class="headerlink" title="EMapVectorclass"></a><code>EMapVector</code>class</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p><code>EMapVector</code>class is an auxiliary class for energy.</p>
<p>An instance of the <code>EMapVector</code> class is a vector that can be used to stores energies.</p>
<h3 id="Example-Analyzing-energy-between-residues"><a href="#Example-Analyzing-energy-between-residues" class="headerlink" title="Example: Analyzing energy between residues"></a>Example: Analyzing energy between residues</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_pose = pyrosetta.toolbox.pose_from_rcsb(<span class="string">&quot;1YY9&quot;</span>) </span><br><span class="line"><span class="comment"># instantiate a `pose` object</span></span><br><span class="line"></span><br><span class="line">residue_102_id = my_pose.pdb_info().pdb2pose(<span class="string">&quot;D&quot;</span>, <span class="number">102</span>) </span><br><span class="line"><span class="comment"># get pose id of residue #102(PDB) on chain D</span></span><br><span class="line">residue_408_id = my_pose.pdb_info().pdb2pose(<span class="string">&quot;A&quot;</span>, <span class="number">408</span>) </span><br><span class="line"><span class="comment"># get pose id of residue #408(PDB) on chain A</span></span><br><span class="line"></span><br><span class="line">residue_102 = my_pose.residue(residue_102_id)</span><br><span class="line">residue_408 = my_pose.residue(residue_408_id)</span><br><span class="line"><span class="comment"># get `residue` objects</span></span><br><span class="line"></span><br><span class="line">my_emap = EMapVector() </span><br><span class="line"><span class="comment"># Instantiate an empty `e_map_vector` object</span></span><br><span class="line"></span><br><span class="line">sfxn = get_score_function(<span class="literal">True</span>) </span><br><span class="line"><span class="comment"># Create a score function `sfxn` using</span></span><br><span class="line"><span class="comment">#  pyrosetta.teaching.get_score_function(); ref2015 scoring function</span></span><br><span class="line"></span><br><span class="line">sfxn.eval_ci_2b(residue_102, residue_408, my_pose, my_emap)</span><br><span class="line"><span class="comment"># Analyzing energy between residues #102(chain D, PDB) and #408(chain A, PDB)</span></span><br><span class="line"><span class="comment"># The outputs are stored in my_emap</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(emap[fa_atr])</span><br><span class="line"><span class="built_in">print</span>(emap[fa_rep])</span><br><span class="line"><span class="built_in">print</span>(emap[fa_sol])</span><br><span class="line"><span class="comment"># visit and print the energy terms that are stored in emap</span></span><br></pre></td></tr></table></figure>



<h2 id="SwitchResidueTypeSetMover-class"><a href="#SwitchResidueTypeSetMover-class" class="headerlink" title="SwitchResidueTypeSetMover class"></a><code>SwitchResidueTypeSetMover</code> class</h2><p>An instance of the <code>SwitchResidueTypeSetMover</code> class is a <code>mover</code> that switches the energy landscape of a pose.</p>
<ul>
<li>“centroid”: a simplified, smooth energy landscape; easy to navigate; fast</li>
<li>“fa_standard”:  a full-atom landscape; rough and sharp; accurate</li>
</ul>
<p>PyRosetta uses different energy terms and different scoring functions for these two energy landscape.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assume that we have a `pose` object my_pose</span></span><br><span class="line">c_switch = SwitchResidueTypeSetMover(<span class="string">&quot;centroid&quot;</span>) </span><br><span class="line"><span class="comment"># `c_switch` is an object that can switch a pose to low-resolution (centroid) energy landscape</span></span><br><span class="line">switch.apply(my_pose) <span class="comment"># apply switch to my_pose</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fa_switch = SwitchResidueTypeSetMover(<span class="string">&quot;fa_standard&quot;</span>)</span><br><span class="line"><span class="comment"># `fa_switch` is an object that can switch a pose to high-resolution (full atom) energy landscape</span></span><br><span class="line">switch.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h2 id="Notes-on-Energy-Terms-ScoreType"><a href="#Notes-on-Energy-Terms-ScoreType" class="headerlink" title="Notes on Energy Terms ScoreType"></a>Notes on Energy Terms <code>ScoreType</code></h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>namespace: <code>pyrosetta.rosetta.core.scoring</code>.</p>
<p>E.g. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scorefxn = get_fa_scorefxn()</span><br><span class="line">scorefxn(pose)</span><br><span class="line">energies = pose.energies()</span><br><span class="line"><span class="comment">#print(energies.residue_total_energies(49))</span></span><br><span class="line"><span class="built_in">print</span>(energies.residue_total_energies(<span class="number">49</span>)[pyrosetta.rosetta.core.scoring.fa_dun])</span><br></pre></td></tr></table></figure>

<h3 id="Notes-on-Abbreviations"><a href="#Notes-on-Abbreviations" class="headerlink" title="Notes on Abbreviations"></a>Notes on Abbreviations</h3><p><code>fa_*</code> indicates that this term is measured in a “full atom” energy landscape.</p>
<p><code>bb</code> means backbone.</p>
<p><code>sc </code>means side chain.</p>
<p><code>vdw</code> for Van der Waal.</p>
<p><code>fa_dun</code> for Dunbrak Energies (of the side chain)</p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (7) Side Chain Packing &amp; Designing</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(7)%20Side%20Chain%20Packing%20&amp;%20Designing/</url>
    <content><![CDATA[<h1 id="PyRosetta-7-Side-Chain-Packing-Designing"><a href="#PyRosetta-7-Side-Chain-Packing-Designing" class="headerlink" title="PyRosetta (7): Side Chain Packing &amp; Designing"></a>PyRosetta (7): Side Chain Packing &amp; Designing</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.teaching <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Core Includes</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.kinematics <span class="keyword">import</span> MoveMap</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.kinematics <span class="keyword">import</span> FoldTree</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.pack.task <span class="keyword">import</span> TaskFactory</span><br><span class="line"><span class="comment">## The operations of a TaskFactory: </span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.pack.task <span class="keyword">import</span> operation</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.simple_metrics <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select <span class="keyword">import</span> residue_selector <span class="keyword">as</span> selections</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core <span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select.movemap <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Protocol Includes</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols <span class="keyword">import</span> minimization_packing <span class="keyword">as</span> pack_min</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols <span class="keyword">import</span> relax <span class="keyword">as</span> rel</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.antibody.residue_selector <span class="keyword">import</span> CDRResidueSelector</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.antibody <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.loops <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.relax <span class="keyword">import</span> FastRelax</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.rosettacommons.org/docs/latest/full-options-list">https://docs.rosettacommons.org/docs/latest/full-options-list</a></p>
<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="Terms-of-pose-operations"><a href="#Terms-of-pose-operations" class="headerlink" title="Terms of pose operations"></a>Terms of pose operations</h3><ol>
<li>“Folding”: Folding of the backbone, optimizing values of  $ \phi $and $ \psi $and $ \omega $.</li>
<li>“Packing”: Packing of the side chains of residues, optimizing values of $ \chi $etc.</li>
<li>“Designing”: Designing of the protein sequence, optimizing the total energy by changing the identities of amino acids.<br>(e.g. substitute an Arg with a Gly).</li>
</ol>
<p>Monte Carlo simulation is the most basic and classic folding algorithm. </p>
<p>The basic process of the Monte Carlo simulation is shared by all folding, packing and design process.</p>
<details class="lake-collapse"><summary id="u85986045"><span class="ne-text">Basic Folding Process using Monte Carlo simulation</span></summary><p id="u1cf4ba01" class="ne-p"><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/gfkfxof6pygtuwkr" data-href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/gfkfxof6pygtuwkr" class="ne-link"><span class="ne-text">Note | PyRosetta Basics (6): Mover</span></a></p><h3 id="e64YK"><span class="ne-text" style="color: rgba(0, 0, 0, 0.87)">Making a trial move</span></h3><p id="u5e5dbfd4" class="ne-p"><span class="ne-text" style="font-size: 14px">Apply a </span><em><span class="ne-text" style="font-size: 14px">move</span></em><span class="ne-text" style="font-size: 14px"> (change) to the </span><em><span class="ne-text" style="font-size: 14px">pose</span></em><span class="ne-text" style="font-size: 14px"> (structure).</span></p><h3 id="irwtJ"><span class="ne-text">Scoring the move</span></h3><p id="u44f841d4" class="ne-p"><span class="ne-text" style="font-size: 14px">Compare the energy scores before and after the move. </span></p><p id="u9e89c1ac" class="ne-p"><span class="ne-text" style="font-size: 14px">(Therefore, the pose should be cloned as a backup before the move.)</span></p><p id="u24599695" class="ne-p"><span class="ne-text" style="font-size: 14px"></span></p><p id="u8cc42be0" class="ne-p"><span class="ne-text" style="font-size: 14px">And, compare the energy score after the </span><em><span class="ne-text" style="font-size: 14px">move</span></em><span class="ne-text" style="font-size: 14px"> and the lowest energy score in history. </span></p><p id="u020e8d13" class="ne-p"><span class="ne-text" style="font-size: 14px">If the score after this </span><em><span class="ne-text" style="font-size: 14px">move</span></em><span class="ne-text" style="font-size: 14px"> is the lowest, store the </span><em><span class="ne-text" style="font-size: 14px">pose </span></em><span class="ne-text" style="font-size: 14px">after this</span><em><span class="ne-text" style="font-size: 14px"> move </span></em><span class="ne-text" style="font-size: 14px">as the best pose, and renew the lowest energy score in history.</span></p><h3 id="TAn8b"><span class="ne-text">Desiding whether or not to accept the move: </span><strong><span class="ne-text">Metropolis criterion</span></strong></h3><p id="ucb6377ba" class="ne-p"><span class="ne-text">For the</span><strong><span class="ne-text"> </span></strong><span class="ne-text">decision step, we need to make a subroutine that either accepts or rejects the new conformatuon based on the </span><strong><span class="ne-text">Metropolis criterion</span></strong><span class="ne-text">. </span></p><p id="u555ca55a" class="ne-p"><span class="ne-text">The difference between the energy scores after (t+1) and before (t) a move is </span><span id="YTTPK" class="ne-math" style="font-size: 14px"><img src="https://cdn.nlark.com/yuque/__latex/140cea98d95645c2586ed9f29e31675b.svg"></span><span class="ne-text">.</span></p><p id="u4257265d" class="ne-p"><span class="ne-text">The Metropolis criterion has a probability of accepting a move as </span><span id="GuL5z" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/862838486b7050697b0dee3c6ecb5d6d.svg"></span><span class="ne-text">.</span></p><p id="ub1003231" class="ne-p"><span class="ne-text">When </span><span id="xfX93" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/fb3b0300200beee945a7c33ee9da1833.svg"></span><span class="ne-text">, the Metropolis criterion probability of accepting the move is </span><span id="BH3hC" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/862838486b7050697b0dee3c6ecb5d6d.svg"></span><span class="ne-text">.</span></p><p id="u03854502" class="ne-p"><span class="ne-text">When </span><span id="jAP7B" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/16d5d059d93f960fa208a43278bc6094.svg"></span><span class="ne-text">, the Metropolis criterion probability of accepting the move is </span><span id="U1a3A" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/54928c26406c51ef50311d6f0d99f3a6.svg"></span><span class="ne-text">. </span></p><p id="ucd6574c7" class="ne-p"><span class="ne-text">Use </span><span id="lfd2T" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/825509854c41e934535f33223f7981f1.svg"></span><span class="ne-text"> . </span></p><p id="u05b7dc94" class="ne-p"><span class="ne-text"></span></p><p id="uf6ba059c" class="ne-p"><span class="ne-text">If the move is accepted, the </span><em><span class="ne-text">pose</span></em><span class="ne-text"> after the </span><em><span class="ne-text">move</span></em><span class="ne-text"> will be used for the next round of trial </span><em><span class="ne-text">move.</span></em></p><p id="ud6027a74" class="ne-p"><span class="ne-text">If not, the </span><em><span class="ne-text">pose</span></em><span class="ne-text"> before the </span><em><span class="ne-text">move </span></em><span class="ne-text">will be used for the next round of trial </span><em><span class="ne-text">move</span></em><span class="ne-text">.</span></p><h3 id="SJZe5"><span class="ne-text">Iterations</span></h3><p id="u892da1c2" class="ne-p"><span class="ne-text">For each iteration, the 3 steps above are excuted. </span></p><p id="u6a79e2e1" class="ne-p"><span class="ne-text">The final output of this program should be the </span><strong><span class="ne-text">lowest energy conformation</span></strong><span class="ne-text"> that is achieved </span><strong><span class="ne-text">at any point</span></strong><span class="ne-text"> during the simulation. </span></p><p id="u53388aed" class="ne-p"><span class="ne-text" style="color: #DF2A3F">NOTICE</span><span class="ne-text">: Search &quot;greedy algorithm&quot; and &quot;Monte Carlo&quot; for more information about the algorithm design. </span></p></details>
### Simulated annealing
Simulated anealing refer to the ramping of temperature `kT`in Python looping.

<ol>
<li>Set a high initial temperature, so that more barriers can be easily overcome.</li>
<li>By gradually decreasing the temperarture after each Python loop, the barriers becomes harder to overcome, and the search range gradually narrows down to a local minimum.</li>
<li>In this process, after a period of “heated” (active) searching across the energy landscape, the energy of a pose is expected to be gradually trapped in a deep trough (valley), which is a reliable local energy minimum (a possible global minimum).</li>
</ol>
<h3 id="Simulated-relaxing"><a href="#Simulated-relaxing" class="headerlink" title="Simulated relaxing"></a>Simulated relaxing</h3><p>Simulated relaxing refer to the ramping of energy score <code>E</code>(and the differences between scores <code>delta_E</code>) in Python looping.</p>
<ol>
<li>Set a small initial weight of an energy term, so that the free energy (and the barriers) are underestimated, and thus the energy barriers are easier to be overcome.</li>
<li>By gradually increasing the weight after each Python loop, the energy estimation becomes more realistic, and the search range gradually narrows down to a local minimum.</li>
<li>In this process, after a period of the “relaxed” (loose) evaluation, energy of a pose is expected to be gradually trapped in a deep trough (valley), which is a reliable local energy minimum (a possible global minimum).</li>
</ol>
<h2 id="Introduction-to-Packing"><a href="#Introduction-to-Packing" class="headerlink" title="Introduction to Packing"></a>Introduction to Packing</h2><p>“Packing” is the process of optimizing the conformation of side chains (values of $ \chi_{n} $and other angles).</p>
<p>The “<em>packer</em>“ is a subset of _movers <em>that apply packing operations to a pose</em>. </p>
<p>We use “task operations” to configure the behaviors of <em>packers</em>:</p>
<ul>
<li>The “task operations” are provided to a <code>TaskFactory</code>object.</li>
<li>The  <code>TaskFactory</code> is then passed to a <em>packer</em>.</li>
</ul>
<h2 id="init-：Initialize-From-Rosetta-Commandline"><a href="#init-：Initialize-From-Rosetta-Commandline" class="headerlink" title="init()：Initialize From Rosetta Commandline"></a><code>init()</code>：Initialize From Rosetta Commandline</h2><p>We can change some defalt Rosetta (C++) commandline settings through</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyrosetta.rosetta.init()</span><br></pre></td></tr></table></figure>

<p>E.g.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># we can change some defalt settings through</span></span><br><span class="line"><span class="comment"># pyrosetta.rosetta.init()</span></span><br><span class="line"><span class="comment"># or, write as:</span></span><br><span class="line"><span class="comment"># pyrosetta.init()</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line">init(<span class="string">&#x27;-use_input_sc -input_ab_scheme AHo_Scheme -ignore_unrecognized_res \</span></span><br><span class="line"><span class="string">     -ignore_zero_occupancy false -load_PDB_components false -relax:default_repeats 5 -no_fconfig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">In this initialization, we</span></span><br><span class="line"><span class="string">1. input the scheme for antibody nomenclature;</span></span><br><span class="line"><span class="string">2. use the PDB ligand definitions to load all standard residue descriptions;</span></span><br><span class="line"><span class="string">3. keep the relax mode as `FastRelax` (which is default);</span></span><br><span class="line"><span class="string">4. and set the `FastRelax` repeat times to 5 (by default it is already 5, can be customized);</span></span><br><span class="line"><span class="string">5. and do not load the [common] config file if present.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="TaskFacrtory-class-prototype-of-PackerTask"><a href="#TaskFacrtory-class-prototype-of-PackerTask" class="headerlink" title="TaskFacrtory class: prototype of PackerTask"></a><code>TaskFacrtory</code> class: prototype of <code>PackerTask</code></h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Instances of<code>PackerTask</code>class are used to determine the specific tasks in packing.</p>
<p><code>TaskFactory</code>is the prototype of <code>PackerTask</code> class.</p>
<p>Every time the protein is packed for a single round, the <code>TaskFactory</code> will generate what is called the <code>PackerTask</code>.</p>
<p>We do NOT use <code>PackerTask</code> directly.</p>
<p>We can set <code>TaskOperations</code>to the <code>TaskFactory</code>, and all <code>PackerTask</code>generated by this<code>TaskFactory</code> will be controlled by these <code>TaskOpterations</code>.</p>
<p>So bascically a <code>TaskFactory</code>object can be seen as “a list of task operations”.</p>
<p>Some <code>TaskOperations</code>can respond to changes in the pose, so we do not set <code>TaskOperations</code> directly to <code>PackerTask</code>in each packing step.</p>
<p>Instead, we use <code>TaskFactory</code>to dynamically generate <code>PackerTask</code>objects in each round, behind the scene. </p>
<h3 id="Instantiation-Configuration-push-back"><a href="#Instantiation-Configuration-push-back" class="headerlink" title="Instantiation &amp; Configuration(push_back)"></a>Instantiation &amp; Configuration(<code>push_back</code>)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tf = TaskFactory() <span class="comment"># Create an empty task factory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># And set task operations to the task factory:</span></span><br><span class="line">my_tf.push_back(operation.InitializeFromCommandline()) </span><br><span class="line"><span class="comment"># IMPORTANT! Use configurations declared in `init()`</span></span><br><span class="line">my_tf.push_back(operation.RestrictToRepacking()) </span><br><span class="line"><span class="comment"># Disable &quot;designing of side chains&quot; so that the sequence will be untouched</span></span><br></pre></td></tr></table></figure>

<h3 id="Regional-Packing-selections-PreventRepackingRLT"><a href="#Regional-Packing-selections-PreventRepackingRLT" class="headerlink" title="Regional Packing: selections &amp; PreventRepackingRLT"></a>Regional Packing: <code>selections</code> &amp; <code>PreventRepackingRLT</code></h3><p>We can also use <code>selections</code>for regional packing</p>
<p>E.g. Selecting CDR H1 region of an antibody</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Selecting CDR H1 region of an antibody</span></span><br><span class="line">cdr_selector = CDRResidueSelector() <span class="comment"># Instantiation</span></span><br><span class="line">cdr_selector.set_cdr(h1) <span class="comment"># Select the H1 loop only</span></span><br><span class="line"><span class="comment"># the namespace of `h1` was imported by commandlines that were passed to init() </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Selecting the Neiborhood (in 3D space) residue of CDR H1</span></span><br><span class="line">nbr_selector = selections.NeighborhoodResidueSelector() <span class="comment"># Instantiation</span></span><br><span class="line">nbr_selector.set_focus_selector(cdr_selector) <span class="comment"># Find neighbors of cdr_selector (which is the H1 loop)</span></span><br><span class="line">nbr_selector.set_include_focus_in_subset(<span class="literal">True</span>) <span class="comment"># Include the H1 loop in `nbr_selector` as well</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&quot;RLT&quot;: Residue Level Task Operation</span></span><br><span class="line">prevent_repacking_rlt = operation.PreventRepackingRLT() <span class="comment"># Instantication</span></span><br><span class="line"></span><br><span class="line">prevent_subset_repacking = operation.OperateOnResidueSubset(prevent_repacking_rlt, nbr_selector, <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#`True` indicates here that we are flipping the selection.  </span></span><br><span class="line"><span class="comment"># So that we are turning off everything but the CDR and its neighbors.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `TaskFactory` named `my_tf`</span></span><br><span class="line">my_tf.push_back(prevent_subset_repacking)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/pcq4wdwkbwrgfmi1">Note | PyRosetta Basics (8): FastRelax</a></p>
<h2 id="PackRotamersMover-class"><a href="#PackRotamersMover-class" class="headerlink" title="PackRotamersMover class"></a><code>PackRotamersMover</code> class</h2><p>A <em>packer</em> is a <em>mover</em> that carries out packing under the instruction of <code>PackerTask</code>.</p>
<h3 id="Use-a-Resfile"><a href="#Use-a-Resfile" class="headerlink" title="Use a Resfile"></a>Use a Resfile</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">operation_resfile = pyrosetta.rosetta.core.pack.task.operation.ReadResfile(resfile)</span><br><span class="line">my_tf.push_back(operation_resfile)</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/file_types/resfiles">Resfile syntax and conventions</a></p>
<p>A Resfile may conflict with operations.</p>
<h3 id="Instantiation-Configurations"><a href="#Instantiation-Configurations" class="headerlink" title="Instantiation &amp; Configurations"></a>Instantiation &amp; Configurations</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `TaskFactory` object called `my_tf`</span></span><br><span class="line">my_packer = pack_min.PackRotamersMover() <span class="comment"># Create a `PackRotamersMover` object</span></span><br><span class="line">my_packer.task_factory(my_tf) <span class="comment"># Pass the `TaskFactory` object to the packer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Note that we are not passing a scorefunction here.  We will use the default, cmd-line scorefunction, </span></span><br><span class="line"><span class="comment"># which can be accessed through `rosetta.core.scoring.get_score_function()`</span></span><br><span class="line"><span class="comment"># We use a scorefunction later. </span></span><br></pre></td></tr></table></figure>

<h3 id="Apply-the-packer-to-a-pose"><a href="#Apply-the-packer-to-a-pose" class="headerlink" title="Apply the packer to a pose"></a>Apply the packer to a pose</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Run the packer. (Note this may take a few minutes)</span></span><br><span class="line">my_packer.apply(pose)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (8) Relax</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(8)%20Relax/</url>
    <content><![CDATA[<h1 id="PyRosetta-8-Relax"><a href="#PyRosetta-8-Relax" class="headerlink" title="PyRosetta (8): Relax"></a>PyRosetta (8): Relax</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>The word “relax” is borrowed from thermodynamics; it refers to the process in which a system gradually recovers to a balanced or equilibrium state from a unbalanced state.</p>
<p>The input pose is considered as a “unbalanced” system, and through the “relax” process, PyRosetta aims to find a “balanced” (globally minimum) system.</p>
<blockquote>
<p>Relax is the main protocol for simple all-atom refinement of structures in the Rosetta force-field. Relax does <strong>not do extensive refinement</strong> and only searches the local conformational space <strong>around the starting structure</strong>. Relax is thus often used in conjunction with more aggressive sampling protocols like fragment assembly (abinitio) and loop modelling. To evaluate different conformations based on their Rosetta all-atom score one usually has to apply relax.</p>
<p>It can also read centroid models, in which case it will convert the model into a full-atom model and pack the sidechains. Relax does not carry out any extensive refinement and only searches the <strong>local conformational space neighbourhood</strong>.</p>
<p>It is further advisable to apply relax only to previously idealized structures. Idealization avoids that score differences arise due to non-ideal geometry (e.g., at the position of former chain-breaks introduced during an aggressive sampling stage and removed by loop closing).</p>
<p><a href="https://docs.rosettacommons.org/docs/latest/application_documentation/structure_prediction/relax">https://docs.rosettacommons.org/docs/latest/application_documentation&#x2F;structure_prediction&#x2F;relax</a></p>
</blockquote>
<h2 id="ClassicRelax"><a href="#ClassicRelax" class="headerlink" title="ClassicRelax"></a><code>ClassicRelax</code></h2><p>Depreciated. Small move + shear move.</p>
<h2 id="FastRelax-default"><a href="#FastRelax-default" class="headerlink" title="FastRelax(default)"></a><code>FastRelax</code>(default)</h2><p>5 cycles of {[packing + minimization] * n_ramping}.</p>
<blockquote>
<p>Packing: optimizing side chain conformations without editing side chains.</p>
<p>Minimization: find local energy minima.</p>
<p>n_ramping: steps of ramping up <code>fa_rep</code> (in each single cycle). In each of the 5 cycles, the repulsion energy (<code>fa_rep</code>) are firstly set to a small number to allow exploration, and then it gradually increases to a realistic value in n-step ramping. The final stages of the ramp enforce the full, realistic energy function, ensuring that the resulting structure has physically correct packing and geometry.</p>
</blockquote>
<p>Pseudo code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `Pose` object called `my_pose`</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>): <span class="comment"># &quot;5&quot; by default, can be modified</span></span><br><span class="line">    fa_rep = <span class="number">0.1</span> * fa_rep</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_ramp):</span><br><span class="line">        fa_rep = Increase(fa_rep)</span><br><span class="line">        Packing(my_pose)</span><br><span class="line">        Minimizing(my_pose)</span><br></pre></td></tr></table></figure>

<h2 id="CentroidRelax-for-massive-screening"><a href="#CentroidRelax-for-massive-screening" class="headerlink" title="CentroidRelax(for massive screening)"></a><code>CentroidRelax</code>(for massive screening)</h2><ol>
<li>It uses centroid score functions</li>
<li>It ramps up various energy terms while minimizing the pose</li>
<li>It is rough but fast, thus is suitable for high-throughput structure design<br>(as a pre-processing &amp; evaluation for further <code>FastRelax</code>).</li>
</ol>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta (9) FastRelax</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20(9)%20FastRelax%20Mover/</url>
    <content><![CDATA[<h1 id="PyRosetta-9-FastRelax"><a href="#PyRosetta-9-FastRelax" class="headerlink" title="PyRosetta (9): FastRelax"></a>PyRosetta (9): FastRelax</h1><h2 id="Initialization-Same-as-the-“Packing”-chapter"><a href="#Initialization-Same-as-the-“Packing”-chapter" class="headerlink" title="Initialization(Same as the “Packing” chapter)"></a>Initialization(Same as the “Packing” chapter)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.teaching <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Core Includes</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.kinematics <span class="keyword">import</span> MoveMap</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.kinematics <span class="keyword">import</span> FoldTree</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.pack.task <span class="keyword">import</span> TaskFactory</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.pack.task <span class="keyword">import</span> operation</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.simple_metrics <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select <span class="keyword">import</span> residue_selector <span class="keyword">as</span> selections</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core <span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select.movemap <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Protocol Includes</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols <span class="keyword">import</span> minimization_packing <span class="keyword">as</span> pack_min</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols <span class="keyword">import</span> relax <span class="keyword">as</span> rel</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.antibody.residue_selector <span class="keyword">import</span> CDRResidueSelector</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.antibody <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.loops <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.protocols.relax <span class="keyword">import</span> FastRelax</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(<span class="string">&#x27;-use_input_sc -input_ab_scheme AHo_Scheme -ignore_unrecognized_res \</span></span><br><span class="line"><span class="string">     -ignore_zero_occupancy false -load_PDB_components false -relax:default_repeats 2 -no_fconfig&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="FastRelax-class"><a href="#FastRelax-class" class="headerlink" title="FastRelax class"></a><code>FastRelax</code> class</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>As is descibe above,</p>
<p>Default FastRelax is:</p>
<blockquote>
<p>5 cycles of {[packing + minimization] * n_ramping_of_fa_rep}.</p>
</blockquote>
<h4 id="TaskFactory"><a href="#TaskFactory" class="headerlink" title="TaskFactory"></a><code>TaskFactory</code></h4><p>We can specify a <code>TaskFactory</code>to instruct packing (Refer to Side Chain Packing and Design for “packing”, “TaskFactory” and “PackerTask”).</p>
<h4 id="MoveMapFactory"><a href="#MoveMapFactory" class="headerlink" title="MoveMapFactory"></a><code>MoveMapFactory</code></h4><p>We can pass in a <code>MoveMapFactory</code> object to instrucrt minimization (Refer to Backbone Folding for “minimization” and “movemap”).</p>
<p>FastRelax is Stochastic, which means that it contains ramdom processes and is not deterministic.</p>
<h4 id="Score-function"><a href="#Score-function" class="headerlink" title="Score function"></a>Score function</h4><p>FastRelax needs a score function for both packing and minimization. The default is “ref_2015”.</p>
<h3 id="Default-Instantiation-Configurations"><a href="#Default-Instantiation-Configurations" class="headerlink" title="Default Instantiation &amp; Configurations"></a>Default Instantiation &amp; Configurations</h3><p>WARNING: If you apply a <code>FastRelax</code>object to a pose without specifying a score function, the kernel would crash. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_fr = FastRelax() <span class="comment"># Instantiation a `FastRelax` object named `my_fr`</span></span><br><span class="line"></span><br><span class="line">my_scorefxn = get_score_function() <span class="comment"># A default ref2015 full atom score function</span></span><br><span class="line"></span><br><span class="line">my_fr.set_scorefxn(my_scorefxn)</span><br><span class="line"></span><br><span class="line"><span class="comment">#FastRelax takes a very long time, </span></span><br><span class="line"><span class="comment">#but we can decrease the amount of minimization cycles by using:</span></span><br><span class="line"><span class="comment"># fr.max_iter(100)</span></span><br><span class="line"><span class="comment">#(Only recommended for cartesian)</span></span><br></pre></td></tr></table></figure>

<h3 id="Customized-Setup-of-Regional-FastRelax"><a href="#Customized-Setup-of-Regional-FastRelax" class="headerlink" title="Customized Setup of Regional FastRelax"></a>Customized Setup of Regional <code>FastRelax</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `FastRelax` object called `my_fr`</span></span><br><span class="line"><span class="comment"># Assume that we have a `MoveMapFactory` object called `my_mmf`</span></span><br><span class="line">my_fr.set_movemap_factory(my_mmf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `TaskFactory` object called `pack_cdrs_and_neighbors_tf`</span></span><br><span class="line">my_fr.set_task_factory(pack_cdrs_and_neighbors_tf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a default ref2015 full atom score function</span></span><br><span class="line">my_fr.set_scorefxn(my_scorefxn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `Pose` object called `my_pose`</span></span><br><span class="line"><span class="comment"># Finally, we can apply the `my_fr` to `my_pose`:</span></span><br><span class="line">my_fr.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h3 id="Apply-FastRelaxto-a-Poseobject"><a href="#Apply-FastRelaxto-a-Poseobject" class="headerlink" title="Apply FastRelaxto a Poseobject"></a>Apply <code>FastRelax</code>to a <code>Pose</code>object</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `Pose` object named `my_pose`</span></span><br><span class="line">my_fr.apply(my_pose)</span><br></pre></td></tr></table></figure>

<h2 id="TaskFactory-class"><a href="#TaskFactory-class" class="headerlink" title="TaskFactory class"></a><code>TaskFactory</code> class</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/serwrtgu16budxyt">Note | PyRosetta Basics (7): Side Chain Packing and Design</a></p>
<blockquote>
<p>Set selectors in packing and design through <code>TaskFactory</code>.</p>
</blockquote>
<p>Instances of<code>PackerTask</code>class are used to determine the specific tasks in packing.</p>
<p><code>TaskFactory</code>is the prototype of <code>PackerTask</code> class.</p>
<p>Every time the protein is packed for a single round, the <code>TaskFactory</code> will generate what is called the <code>PackerTask</code>.</p>
<p>We do NOT use <code>PackerTask</code> directly.</p>
<p>We can set <code>TaskOperations</code>to the <code>TaskFactory</code>, and all <code>PackerTask</code>generated by this<code>TaskFactory</code> will be controlled by these <code>TaskOpterations</code>.</p>
<p>So bascically a <code>TaskFactory</code>object can be seen as “a list of task operations”.</p>
<p>Some <code>TaskOperations</code>can respond to changes in the pose, so we do not set <code>TaskOperations</code> directly to <code>PackerTask</code>in each packing step.</p>
<p>Instead, we use <code>TaskFactory</code>to dynamically generate <code>PackerTask</code>objects in each round, behind the scene. </p>
<h3 id="Instantiation-Configuration-push-back"><a href="#Instantiation-Configuration-push-back" class="headerlink" title="Instantiation &amp; Configuration(push_back)"></a>Instantiation &amp; Configuration(<code>push_back</code>)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tf = TaskFactory() <span class="comment"># Create an empty task factory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># And set task operations to the task factory:</span></span><br><span class="line">my_tf.push_back(operation.InitializeFromCommandline()) </span><br><span class="line"><span class="comment"># IMPORTANT! Use configurations declared in `init()`</span></span><br><span class="line">my_tf.push_back(operation.RestrictToRepacking()) </span><br><span class="line"><span class="comment"># Disable &quot;designing of side chains&quot; so that the sequence will be untouched</span></span><br></pre></td></tr></table></figure>



<h3 id="Regional-Packing-selections-PreventRepackingRLT"><a href="#Regional-Packing-selections-PreventRepackingRLT" class="headerlink" title="Regional Packing: selections &amp; PreventRepackingRLT"></a>Regional Packing: <code>selections</code> &amp; <code>PreventRepackingRLT</code></h3><p>We can also use <code>selections</code>for regional packing</p>
<p>E.g. Selecting CDR H1 region of an antibody</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Selecting CDR H1 region of an antibody</span></span><br><span class="line">cdr_selector = CDRResidueSelector() <span class="comment"># Instantiation</span></span><br><span class="line">cdr_selector.set_cdr(h1) <span class="comment"># Select the H1 loop only</span></span><br><span class="line"><span class="comment"># the namespace of `h1` was imported by commandlines that were passed to init() </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Selecting the Neiborhood (in 3D space) residue of CDR H1</span></span><br><span class="line">nbr_selector = selections.NeighborhoodResidueSelector() <span class="comment"># Instantiation</span></span><br><span class="line">nbr_selector.set_focus_selector(cdr_selector) <span class="comment"># Find neighbors of cdr_selector (which is the H1 loop)</span></span><br><span class="line">nbr_selector.set_include_focus_in_subset(<span class="literal">True</span>) <span class="comment"># Include the H1 loop in `nbr_selector` as well</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&quot;RLT&quot;: Residue Level Task Operation</span></span><br><span class="line">prevent_repacking_rlt = operation.PreventRepackingRLT() <span class="comment"># Instantication</span></span><br><span class="line"></span><br><span class="line">prevent_subset_repacking = operation.OperateOnResidueSubset(prevent_repacking_rlt, nbr_selector, <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#`True` indicates here that we are flipping the selection.  </span></span><br><span class="line"><span class="comment"># So that we are turning off everything but the CDR and its neighbors.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `TaskFactory` named `my_tf`</span></span><br><span class="line">my_tf.push_back(prevent_subset_repacking)</span><br></pre></td></tr></table></figure>

<h3 id="TaskFacrtory-Methods"><a href="#TaskFacrtory-Methods" class="headerlink" title="TaskFacrtory Methods"></a><code>TaskFacrtory</code> Methods</h3><h4 id="Add-operations-TaskFacrtory-push-back"><a href="#Add-operations-TaskFacrtory-push-back" class="headerlink" title="Add operations: TaskFacrtory.push_back"></a>Add operations: <code>TaskFacrtory.push_back</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tf.push_back(my_operation) </span><br><span class="line"><span class="comment"># E.g.</span></span><br><span class="line">my_tf.push_back(operation.InitializeFromCommandline())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A standard setting:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Take command line settings from init()</span></span><br><span class="line">tf.push_back(operation.InitializeFromCommandline())</span><br><span class="line"><span class="comment">## Include the current rotamer of the pose</span></span><br><span class="line">tf.push_back(operation.IncludeCurrent())</span><br><span class="line"><span class="comment">## Disallow repacking Disulfides</span></span><br><span class="line">tf.push_back(operation.NoRepackDisulfides())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pyrosetta.rosetta.core.pack.task.operation</p>
</blockquote>
<h4 id="Clear-all-operations-TaskFacrtory-clear"><a href="#Clear-all-operations-TaskFacrtory-clear" class="headerlink" title="Clear all operations: TaskFacrtory.clear"></a>Clear all operations: <code>TaskFacrtory.clear</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tf.clear()</span><br></pre></td></tr></table></figure>

<h4 id="Preview-of-task-applied-to-a-Poseobject"><a href="#Preview-of-task-applied-to-a-Poseobject" class="headerlink" title="Preview of task applied to a Poseobject"></a>Preview of task applied to a <code>Pose</code>object</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Preview a task generated by a `TaskFactory` object</span></span><br><span class="line">task_design = my_tf.create_task_and_apply_taskoperations( my_pose )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print numbers of packable residues</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Num packable residues: &quot;</span>, task_design.num_to_be_packed())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print numbers of designable residues</span></span><br><span class="line">num_designable = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, my_pose.size() + <span class="number">1</span> ):</span><br><span class="line">    <span class="keyword">if</span>( task_design.design_residue( i ) ):</span><br><span class="line">        num_designable += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Num designable residues: &quot;</span>, num_designable )</span><br></pre></td></tr></table></figure>

<h4 id="Set-Residue-file-Resfile-for-a-TaskFactoryobject"><a href="#Set-Residue-file-Resfile-for-a-TaskFactoryobject" class="headerlink" title="Set Residue file (Resfile) for a TaskFactoryobject"></a>Set Residue file (<code>Resfile</code>) for a <code>TaskFactory</code>object</h4><p>Resfile Syntax: <a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/file_types/resfiles">Resfile syntax and conventions</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.push_back(pyrosetta.rosetta.core.pack.task.operation.ReadResfile(<span class="string">&quot;./path/to/my_resfile&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p><a href="https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.pack.task.operation.html">https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.pack.task.operation.html</a></p>
<h2 id="MoveMapFactory-class"><a href="#MoveMapFactory-class" class="headerlink" title="MoveMapFactory class"></a><code>MoveMapFactory</code> class</h2><h3 id="Introduction-to-MoveMapFactory-class"><a href="#Introduction-to-MoveMapFactory-class" class="headerlink" title="Introduction to MoveMapFactory class"></a>Introduction to <code>MoveMapFactory</code> class</h3><blockquote>
<p>Set restrictions to degree of freedom in Minimization through a <code>MoveMapFactory</code> object.</p>
</blockquote>
<p><code>MoveMapFactory</code>is the prototype of <code>MoveMap</code>.</p>
<p><code>MoveMap</code> instructs a mover; in <code>FastRelax</code>, it instructs minimization mover.</p>
<p>The default is to have everything OFF first, and turn specific things on.</p>
<p>Degree of freedom settings (to a specific region of the pose) requires:</p>
<ol>
<li>pre-defined residue selectors</li>
<li>the pose</li>
</ol>
<p>So residue selectors are designed to be passed to the <code>MoveMapFactory</code>.</p>
<p><code>pyrosetta.rosetta.core.select.movemap.MoveMapFactory()</code></p>
<p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/gfkfxof6pygtuwkr">Note | PyRosetta Basics (6): Movers for Backbone Folding</a></p>
<p><a href="https://www.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/MoveMapFactories/MoveMapFactories-RosettaScripts">MoveMapFactories (RosettaScripts)</a></p>
<h3 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Establish Residue Selector</span></span><br><span class="line">cdr_selector = CDRResidueSelector()</span><br><span class="line">cdr_selector.set_cdr(h1)</span><br><span class="line"><span class="comment"># h1 is a Enum imported when we imported the antibody namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate a `MoveMapFactory` object named &quot;my_mmf&quot;</span></span><br><span class="line">my_mmf = MoveMapFactory()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then setup `my_mmf`</span></span><br><span class="line"><span class="comment"># E.g.</span></span><br><span class="line">mmf.all_bb(setting=<span class="literal">True</span>)</span><br><span class="line">mmf.all_chi(setting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="MoveMapFactory-methods"><a href="#MoveMapFactory-methods" class="headerlink" title="MoveMapFactory methods"></a><code>MoveMapFactory</code> methods</h3><blockquote>
<p>Setup the <code>MoveMapFactory</code>object</p>
</blockquote>
<h4 id="Pass-a-Boolean-to-setting-prop"><a href="#Pass-a-Boolean-to-setting-prop" class="headerlink" title="Pass a Boolean to setting prop"></a>Pass a Boolean to <code>setting</code> prop</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mmf.all_bb(setting=<span class="literal">True</span>)</span><br><span class="line">mmf.all_bondangles(setting=<span class="literal">True</span>)</span><br><span class="line">mmf.all_bondlengths(setting=<span class="literal">True</span>)</span><br><span class="line">mmf.all_chi(setting=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Allow `jumps` to move (For the definition of `jump`, see FoldTree terms) </span></span><br><span class="line">mmf.all_jumps(setting=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Use xyz (Cartesian space)</span></span><br><span class="line">mmf.set_cartesian(setting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Pass-Enums-and-selectors"><a href="#Pass-Enums-and-selectors" class="headerlink" title="Pass Enums and selectors"></a>Pass Enums and selectors</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mm_enable and mm_disable are Enums (numbered variables) </span></span><br><span class="line"><span class="string"> that come when we import the MMF</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">mmf.add_bb_action(mm_enable, cdr_selector)</span><br></pre></td></tr></table></figure>

<h4 id="Settings-for-individual-residue"><a href="#Settings-for-individual-residue" class="headerlink" title="Settings for individual residue"></a>Settings for individual residue</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">If needed, you could turn off bb and chi torsions </span></span><br><span class="line"><span class="string"> for individual residues like this:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># subset_to_minimize is a list (vector) of residue locations</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, pose.size() + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> subset_to_minimize[i]):</span><br><span class="line">        mm.set_bb(i, <span class="literal">False</span>)</span><br><span class="line">        mm.set_chi(i, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Check-the-MoveMapFactory-settings"><a href="#Check-the-MoveMapFactory-settings" class="headerlink" title="Check the MoveMapFactory settings"></a>Check the <code>MoveMapFactory</code> settings</h3><p>Based on the <code>MoveMapFactory</code>, we can create a <code>MoveMap</code>object from a <code>Pose</code>object, and thus we can check the settings.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Instantiate a `MoveMap` object from `my_mmf`</span></span><br><span class="line"><span class="comment"># We need to pass in a `Pose` object (`my_pose`)</span></span><br><span class="line">my_mm  = my_mmf.create_movemap_from_pose(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inspect my_mm</span></span><br><span class="line"><span class="built_in">print</span>(my_mm)</span><br></pre></td></tr></table></figure>

<h3 id="Optimization-through-MoveMapFactory"><a href="#Optimization-through-MoveMapFactory" class="headerlink" title="Optimization through MoveMapFactory"></a>Optimization through <code>MoveMapFactory</code></h3><p>Basic Setup may cause large conformation shifts that we don’t want.</p>
<p>We can tackle this problem either by using a different score function, or by customizing the <code>FoldTree</code>.</p>
<h4 id="Cartesian-space-refinement-ref2015-cart"><a href="#Cartesian-space-refinement-ref2015-cart" class="headerlink" title="Cartesian-space refinement ref2015_cart"></a>Cartesian-space refinement <code>ref2015_cart</code></h4><p>Cartesian-space: the space descibed in X Y Z coordinates.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create score function specified for Cartesian</span></span><br><span class="line">cart_sf = create_score_function(<span class="string">&quot;ref2015_cart&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `MoveMapFactory` object called `my_mmf`</span></span><br><span class="line">my_mmf.set_cartesian(<span class="literal">True</span>) <span class="comment"># Turn &quot;Cartesian mode&quot; on.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `FastRelax` object called `my_fr`</span></span><br><span class="line">my_fr.set_movemap_factory(my_mmf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use `cart_sf` as the score function for FastRelax</span></span><br><span class="line">my_fr.set_scorefxn(cart_sf)</span><br><span class="line">my_fr.cartesian(<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># my_fr.min_type(&quot;lbfgs_armijo_nonmonotone&quot;)</span></span><br><span class="line"><span class="comment">#This is a general recommendation for cartesian minimization - it lowers the number of maximum cycles.</span></span><br><span class="line"><span class="comment"># More than this only increases time of protocol, but has little effect on energies/structure</span></span><br><span class="line">my_fr.max_iter(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>These settings are Cartesian-specifc. They are turned off by default. Turn them off under other circumstances.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_mmf.set_cartesian(<span class="literal">False</span>)</span><br><span class="line">my_fr.cartesian(<span class="literal">False</span>)</span><br><span class="line">my_fr.max_iter(<span class="number">0</span>) <span class="comment">#Reset to default</span></span><br><span class="line"><span class="comment"># my_fr.min_type(&quot;dfpmin_armijo_nonmonotone&quot;) # This seems to be a legacy thing</span></span><br></pre></td></tr></table></figure>

<h4 id="Customizing-FoldTree-A-Classic-way"><a href="#Customizing-FoldTree-A-Classic-way" class="headerlink" title="Customizing FoldTree (A Classic way)"></a>Customizing <code>FoldTree</code> (A Classic way)</h4><p>WARNING: If Cartesian has been turned on, we should turn Cartesian off before using this solution.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assume that we have a `Pose` object named `my_pose`, and it is an antibody</span></span><br><span class="line">ab_info = AntibodyInfo(my_pose) <span class="comment"># Get antibody-specific information</span></span><br><span class="line">my_ft = FoldTree() <span class="comment"># Instantiate an empty FolTree</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get CDR H1 loop parameters</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; #</span></span><br><span class="line">start = ab_info.get_CDR_start(h1, my_pose)</span><br><span class="line">stop =  ab_info.get_CDR_end(h1, my_pose)</span><br><span class="line">cutpoint = <span class="built_in">int</span>((stop-start)/<span class="number">2</span>) + start</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; #</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the loop</span></span><br><span class="line">cdr_loop = Loop(start, stop, cutpoint)</span><br><span class="line">cdr_loops = Loops()</span><br><span class="line">cdr_loops.add_loop(cdr_loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup of `my_ft`</span></span><br><span class="line">fold_tree_from_loops(my_pose, cdr_loops, my_ft) </span><br><span class="line"></span><br><span class="line">my_pose.fold_tree(my_ft)</span><br><span class="line">original_ft = my_pose.fold_tree() <span class="comment"># Backup the original fold tree</span></span><br><span class="line">add_cutpoint_variants(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a default full atom score function</span></span><br><span class="line">scorefxn = get_score_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add chainbreak term to `scorefxn` so we don&#x27;t get wacky stuff.  </span></span><br><span class="line"><span class="comment"># This term helps keep the peptide closed during bb movement.</span></span><br><span class="line">scorefxn_ch = scorefxn <span class="comment"># Copy the default score function</span></span><br><span class="line">scorefxn_ch.set_weight(rosetta.core.scoring.chainbreak, <span class="number">100</span>) <span class="comment"># Add chainbreak term</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `FastRelax` object called `my_fr`</span></span><br><span class="line">my_fr.set_scorefxn(scorefxn_ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume that we have a `MoveMap` object (with basic configurations) called `my_mmf`</span></span><br><span class="line">my_fr.set_movemap_factory(my_mmf)</span><br><span class="line"></span><br><span class="line">my_fr.max_iter(<span class="number">0</span>) <span class="comment">#Reset to default </span></span><br><span class="line"><span class="comment"># if it&#x27;s 0, then we don&#x27;t set it in the MinMover that FastRelax runs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start FastRelax</span></span><br><span class="line">my_fr.apply(my_pose)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Reapply the original fold tree</span></span><br><span class="line">my_pose.fold_tree(original_ft)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta Initiation</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20Initiation/</url>
    <content><![CDATA[<h1 id="PyRosetta-Initiation"><a href="#PyRosetta-Initiation" class="headerlink" title="PyRosetta Initiation"></a>PyRosetta Initiation</h1><h2 id="Basic-Initiation"><a href="#Basic-Initiation" class="headerlink" title="Basic Initiation"></a>Basic Initiation</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line">init </span><br><span class="line"><span class="comment"># pyrosetta.rosetta.init() # We can pass in Rosetta commandlines here</span></span><br><span class="line"><span class="comment">#import pyrosetta</span></span><br><span class="line"><span class="comment">#pyrosetta.init</span></span><br></pre></td></tr></table></figure>

<h2 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(extra_options=<span class="string">&quot;-multithreading:total_threads 8 -multithreading:interaction_graph_threads 4&quot;</span>) </span><br><span class="line"><span class="comment"># `8` and `4` is the numbers of threads as an example</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">init(-multithreading -total_threads &lt;int&gt;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Enabling-Extra-χ-Sampling"><a href="#Enabling-Extra-χ-Sampling" class="headerlink" title="Enabling Extra χ Sampling"></a>Enabling Extra χ Sampling</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(-ex1 -ex2)</span><br></pre></td></tr></table></figure>

<h2 id="Linear-Memory-Interaction-Graph"><a href="#Linear-Memory-Interaction-Graph" class="headerlink" title="Linear Memory Interaction Graph"></a>Linear Memory Interaction Graph</h2><p>For speed, the Packer uses an “Interaction Graph” to cache the residue interaction energies. (See <a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/options/packing-options">packing-options</a> for command line options to control the packer.) Depending on the protocol you’re using, maintaining this interaction graph can account for a considerable amount of time and memory. As such, different interaction graphs (IG) are available.</p>
<ul>
<li>The default interaction graph (the Pairwise Decomposable Interaction Graph) is good for general repacking applications.</li>
<li>For design, the Linear Memory Interaction Graph (<code>-linmem_ig</code>) reduces both the memory and runtime over the default interaction graph</li>
<li>The Lazy Interaction Graph (<code>-lazy_ig</code>) is in all cases faster than the Linear Memory Interaction Graph, but at the cost of more memory usage.</li>
<li>The Double Lazy Interaction Graph (<code>-double_lazy_ig</code>) is only useful for multistate design.</li>
</ul>
<p><code>-linmem_ig</code> behaves as a boolean. If the flag is passed, it activates use of LinearMemoryInteractionGraph (as it should). The value passed to the flag is supposed to control how <em>much</em> memory is used in the linmem_ig, but it does not; it is hardcoded (I think to an effective value of 10).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(-linmem_ig <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Mute-Unmute-outputs-from-Tracer-channel"><a href="#Mute-Unmute-outputs-from-Tracer-channel" class="headerlink" title="Mute&#x2F;Unmute outputs from Tracer channel"></a>Mute&#x2F;Unmute outputs from <code>Tracer</code> channel</h2><p>All output messages have channel + priority level assign to them. User can dynamically, in run time specify command line options to mute&#x2F;unmute specific&#x2F;all channels and to change level of output.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(-mute core.select.residue_selector.SecondaryStructureSelector) </span><br><span class="line"><span class="comment"># Mute specified Tracer channels; specify &#x27;all&#x27; to mute all channels.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init(-unmute core.select.residue_selector.SecondaryStructureSelector)</span><br><span class="line"><span class="comment"># Unmute specified Tracer channels; specify &#x27;all&#x27; to mute all channels.</span></span><br></pre></td></tr></table></figure>

<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><a href="https://docs.rosettacommons.org/docs/latest/full-options-list">https://docs.rosettacommons.org/docs/latest/full-options-list</a></p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>PyRosetta Packer Task Operations</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20Packer%20Task%20Operations/</url>
    <content><![CDATA[<h1 id="PyRosetta-Packer-Task-Operations"><a href="#PyRosetta-Packer-Task-Operations" class="headerlink" title="PyRosetta Packer Task Operations"></a>PyRosetta Packer Task Operations</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.pack.task.operation <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h2 id="Prevent-residues-from-repacking-designing"><a href="#Prevent-residues-from-repacking-designing" class="headerlink" title="Prevent residues from repacking&#x2F;designing"></a>Prevent residues from repacking&#x2F;designing</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PreventRepackingRLT()</span></span><br><span class="line">my_task_factory.push_back(PreventRepackingRLT())</span><br></pre></td></tr></table></figure>

<h2 id="Allowing-repacking-but-disallowing-designing"><a href="#Allowing-repacking-but-disallowing-designing" class="headerlink" title="Allowing repacking, but disallowing designing"></a>Allowing repacking, but disallowing designing</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RestrictToRepackingRLT()</span></span><br><span class="line">my_task_factory.push_back(RestrictToRepackingRLT())</span><br></pre></td></tr></table></figure>

<h2 id="Operate-on-selected-residues"><a href="#Operate-on-selected-residues" class="headerlink" title="Operate on selected residues"></a>Operate on selected residues</h2><p>See PyRosetta Selectors</p>
<p><a href="https://www.yuque.com/yuqueyonghu2r84jv/zmy8pd/egpmv54vv2o0653h">Note | PyRosetta Selectors</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">no_packing_non_interface = OperateOnResidueSubset(PreventRepackingRLT(), not_interface_selector)</span><br><span class="line"><span class="comment"># Push it back to a TaskFactory object just like any other operations</span></span><br><span class="line">my_task_factory.push_back( no_packing_non_interface )</span><br></pre></td></tr></table></figure>

<h2 id="Restrict-design-to-user-specified-residue"><a href="#Restrict-design-to-user-specified-residue" class="headerlink" title="Restrict design to user-specified residue"></a>Restrict design to user-specified residue</h2><p>Restrict design to user-specified residues. If resnum is left as 0, the restriction will apply throughout the pose.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable design on chain_A</span></span><br><span class="line">aa_to_design = pyrosetta.rosetta.core.pack.task.operation.RestrictAbsentCanonicalAASRLT()</span><br><span class="line">aa_to_design.aas_to_keep(<span class="string">&quot;ACDEFGHIKLMNPQRSTVWY&quot;</span>)</span><br><span class="line">tf.push_back(pyrosetta.rosetta.core.pack.task.operation.OperateOnResidueSubset(</span><br><span class="line">    aa_to_design, chain_A))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyrosetta Selectors</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/PyRosetta%20Selectors/</url>
    <content><![CDATA[<h1 id="Pyrosetta-Selectors"><a href="#Pyrosetta-Selectors" class="headerlink" title="Pyrosetta Selectors"></a>Pyrosetta Selectors</h1><p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/ResidueSelectors/ResidueSelectors#residueselectors_logical-residueselectors_andresidueselector">ResidueSelectors</a></p>
<p><a href="https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.select.residue_selector.html">residue_selector — PyRosetta 4.0 documentation</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import all selectors via:</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select.residue_selector <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># For previewing selected residues</span></span><br><span class="line"><span class="keyword">from</span> pyrosetta.rosetta.core.select <span class="keyword">import</span> get_residues_from_subset </span><br></pre></td></tr></table></figure>

<h2 id="Select-a-type-of-residues-by-their-name-symbol"><a href="#Select-a-type-of-residues-by-their-name-symbol" class="headerlink" title="Select a type of residues by their name (symbol)"></a>Select a type of residues by their name (symbol)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># E.g. Select all cysteines</span></span><br><span class="line">cys_res = ResidueNameSelector(<span class="string">&quot;CYS&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Select-a-residue-by-its-index-and-select-its-neighbors"><a href="#Select-a-residue-by-its-index-and-select-its-neighbors" class="headerlink" title="Select a residue by its index, and select its neighbors"></a>Select a residue by its index, and select its neighbors</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select Mutate Position</span></span><br><span class="line">mut_posi = ResidueIndexSelector()</span><br><span class="line">mut_posi.set_index(<span class="number">130</span>)</span><br><span class="line"><span class="comment"># Or, select multiple positions to be mutated</span></span><br><span class="line"><span class="comment"># Note: The residue index is that of poses, not pdb indexes</span></span><br><span class="line"><span class="comment"># You can pass in pdb indexes. See official document listed above</span></span><br><span class="line">mut_posi = ResidueIndexSelector(<span class="string">&quot;163,164,165&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Then Select Neighboring Position</span></span><br><span class="line">nbr_selector = pyrosetta.rosetta.core.select.residue_selector.NeighborhoodResidueSelector()</span><br><span class="line">nbr_selector.set_focus_selector(mut_posi)</span><br><span class="line">nbr_selector.set_include_focus_in_subset(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Select-a-chain-by-its-name"><a href="#Select-a-chain-by-its-name" class="headerlink" title="Select a chain by its name"></a>Select a chain by its name</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select chain A (in pdb)</span></span><br><span class="line">chain_A = ChainSelector(<span class="string">&quot;A&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Select-a-chain-by-its-ID-in-pose"><a href="#Select-a-chain-by-its-ID-in-pose" class="headerlink" title="Select a chain by its ID in pose"></a>Select a chain by its ID in pose</h2><p>Chain ID: automatically numbered, starting from 1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select the first chain in pose</span></span><br><span class="line">chain_A = ChainSelector(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Select-interface"><a href="#Select-interface" class="headerlink" title="Select interface"></a>Select interface</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">interface_selector = InterGroupInterfaceByVectorSelector(chain1, chain2)</span><br></pre></td></tr></table></figure>

<h2 id="Select-all"><a href="#Select-all" class="headerlink" title="Select all"></a>Select all</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_true_selector = TrueResidueSelector() </span><br></pre></td></tr></table></figure>

<h2 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># AND</span></span><br><span class="line"><span class="string">Select all residues that match both conditions:</span></span><br><span class="line"><span class="string">1. it is a Cys;</span></span><br><span class="line"><span class="string">2. it is in chain A.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">chain_A_cys_res = AndResidueSelector(selector1=cys_res, selector2=chain_A)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># NOT</span></span><br><span class="line"><span class="string">Invert selection.</span></span><br><span class="line"><span class="string">Works well when used with RestrictToRepackingRLT()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">not_chain_A_cys_res = NotResidueSelector(chain_A_cys_res)</span><br></pre></td></tr></table></figure>

<h2 id="Preview-selected-residues-ID"><a href="#Preview-selected-residues-ID" class="headerlink" title="Preview selected residues ID"></a>Preview selected residues ID</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># E.g. </span></span><br><span class="line"><span class="built_in">print</span>(get_residues_from_subset(cys_res.apply(my_pose)))</span><br><span class="line"><span class="built_in">print</span>(get_residues_from_subset(chain_A.apply(my_pose)))</span><br></pre></td></tr></table></figure>

<h2 id="Interface-selector"><a href="#Interface-selector" class="headerlink" title="Interface selector"></a>Interface selector</h2><p>The InterGroupInterfaceByVectorSelector identifies residues at the interface between two groups of residues using two distance cutoffs: the first, shorter cutoff is based on atom-atom distances, the second, longer cutoff is used if the c-alpha&#x2F;c-beta vector of the residues in the first group point toward the c-alphas of the other group. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select the interface between chain A and chain B</span></span><br><span class="line">interface_selector = InterGroupInterfaceByVectorSelector(chain_A, chain_B)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyrosetta Resources</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/Pyrosetta%20Resources/</url>
    <content><![CDATA[<h1 id="Pyrosetta-Resources"><a href="#Pyrosetta-Resources" class="headerlink" title="Pyrosetta Resources"></a>Pyrosetta Resources</h1><h2 id="Guide"><a href="#Guide" class="headerlink" title="Guide"></a>Guide</h2><p><a href="https://docs.rosettacommons.org/docs/latest/getting_started/I-want-to-do-x#docking">https://docs.rosettacommons.org/docs/latest/getting_started&#x2F;I-want-to-do-x#docking</a></p>
<h2 id="Energy-terms"><a href="#Energy-terms" class="headerlink" title="Energy terms"></a>Energy terms</h2><p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/score-types">https://docs.rosettacommons.org/docs/latest/rosetta_basics&#x2F;scoring&#x2F;score-types</a></p>
<p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/scoring/centroid-score-terms">https://docs.rosettacommons.org/docs/latest/rosetta_basics&#x2F;scoring&#x2F;centroid-score-terms</a></p>
<h2 id="Movers"><a href="#Movers" class="headerlink" title="Movers"></a>Movers</h2><p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/Movers/movers_pages/PyMolMover">https://docs.rosettacommons.org/docs/latest/scripting_documentation&#x2F;RosettaScripts&#x2F;Movers&#x2F;movers_pages&#x2F;PyMolMover</a></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://docs.rosettacommons.org/docs/latest/getting_started/FAQ">https://docs.rosettacommons.org/docs/latest/getting_started&#x2F;FAQ</a></p>
<h2 id="initcommands-Important"><a href="#initcommands-Important" class="headerlink" title="initcommands(Important)"></a><code>init</code>commands(Important)</h2><p><a href="https://docs.rosettacommons.org/docs/latest/full-options-list">https://docs.rosettacommons.org/docs/latest/full-options-list</a></p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><a href="https://docs.rosettacommons.org/manuals/archive/rosetta_3.8_user_guide/all_else/d2/d2a/namespacepyrosetta.html">https://docs.rosettacommons.org/manuals/archive/rosetta_3.8_user_guide&#x2F;all_else&#x2F;d2&#x2F;d2a&#x2F;namespacepyrosetta.html</a></p>
<h2 id="Resfile-syntax"><a href="#Resfile-syntax" class="headerlink" title="Resfile syntax"></a>Resfile syntax</h2><p><a href="https://docs.rosettacommons.org/docs/latest/rosetta_basics/file_types/resfiles">https://docs.rosettacommons.org/docs/latest/rosetta_basics&#x2F;file_types&#x2F;resfiles</a></p>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p><a href="https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.pack.task.operation.html">https://graylab.jhu.edu/PyRosetta.documentation/pyrosetta.rosetta.core.pack.task.operation.html</a></p>
<h2 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h2><p><a href="https://docs.rosettacommons.org/docs/latest/scripting_documentation/RosettaScripts/ResidueSelectors/ResidueSelectors#residueselectors_conformation-independent-residue-selectors_chainselector">https://docs.rosettacommons.org/docs/latest/scripting_documentation&#x2F;RosettaScripts&#x2F;ResidueSelectors&#x2F;ResidueSelectors#residueselectors_conformation-independent-residue-selectors_chainselector</a></p>
<h2 id="Citations"><a href="#Citations" class="headerlink" title="Citations"></a>Citations</h2><p>FastRelax Mover’s citation(s):</p>
<p>*Tyka MD, *Keedy DA, André I, Dimaio F, Song Y, Richardson DC, Richardson JS, and Baker D.  (2011).  Alternate states of proteins revealed by detailed energy landscape mapping.  J Mol Biol 405(2):607-18.  doi: 10.1016&#x2F;j.jmb.2010.11.008.  (*Co-primary authors.)</p>
<p>Khatib F, Cooper S, Tyka MD, Xu K, Makedon I, Popovic Z, Baker D, and Players F.  (2011).  Algorithm discovery by protein folding game players.  Proc Natl Acad Sci USA 108(47):18949-53.  doi: 10.1073&#x2F;pnas.1115898108.</p>
<p>Maguire JB, Haddox HK, Strickland D, Halabiya SF, Coventry B, Griffin JR, Pulavarti SVSRK, Cummins M, Thieker DF, Klavins E, Szyperski T, DiMaio F, Baker D, and Kuhlman B.  (2021).  Perturbing the energy landscape for improved packing during computational protein design.  Proteins 89(4):436-449.  doi: 10.1002&#x2F;prot.26030.</p>
]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>Rosetta从PDB坐标生成蓝图BluePrint</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/Rosetta%20BluePrint/</url>
    <content><![CDATA[<h1 id="Rosetta从PDB坐标生成蓝图BluePrint"><a href="#Rosetta从PDB坐标生成蓝图BluePrint" class="headerlink" title="Rosetta从PDB坐标生成蓝图BluePrint"></a>Rosetta从PDB坐标生成蓝图BluePrint</h1><h2 id="它是用来做什么的？"><a href="#它是用来做什么的？" class="headerlink" title="它是用来做什么的？"></a>它是用来做什么的？</h2><p><a href="https://zhuanlan.zhihu.com/p/68849859">RosettaRemodel: 多才多艺的蛋白结构设计工具包 - 知乎</a></p>
<h2 id="它在哪里？"><a href="#它在哪里？" class="headerlink" title="它在哪里？"></a>它在哪里？</h2><p><code>rosetta/main/tools/remodel/getBluePrintFromCoords.pl</code></p>
<h2 id="如何使用它？（最小使用例）"><a href="#如何使用它？（最小使用例）" class="headerlink" title="如何使用它？（最小使用例）"></a>如何使用它？（最小使用例）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd到getBluePrintFromCoords.pl所在目录</span></span><br><span class="line"><span class="comment">#假设有一个PDB文件位于当前目录，名称为my_file.pdb</span></span><br><span class="line"><span class="comment">#假设我们希望指定输出的蓝图文件名为blueprint.remodel</span></span><br><span class="line">perl getBluePrintFromCoords.pl -pdbfile ~/my_path/my_file.pdb &gt; blueprint.remodel</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
  <entry>
    <title>Uncategorized PyRosetta Utils</title>
    <url>/project/2025/10/12/PyRosetta%20&amp;%20Rosetta/Uncategorized%20PyRosetta%20Utils/</url>
    <content><![CDATA[<h1 id="Uncategorized-PyRosetta-Utils"><a href="#Uncategorized-PyRosetta-Utils" class="headerlink" title="Uncategorized PyRosetta Utils"></a>Uncategorized PyRosetta Utils</h1><h2 id="Clean-ATOM"><a href="#Clean-ATOM" class="headerlink" title="Clean ATOM"></a>Clean ATOM</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyrosetta <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyrosetta.teaching <span class="keyword">import</span> *</span><br><span class="line">cleanATOM(<span class="string">&#x27;./my_file.pdb&#x27;</span>)</span><br><span class="line"><span class="comment"># It will generate a file named &#x27;my_file.clean.pdb&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Evaluate-how-much-is-a-pose-changed"><a href="#Evaluate-how-much-is-a-pose-changed" class="headerlink" title="Evaluate how much is a pose changed"></a>Evaluate how much is a pose changed</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyrosetta.rosetta.core.scoring.CA_rmsd(start_pose, end_pose)</span><br></pre></td></tr></table></figure>

<h2 id="Convert-sequence-of-a-pose-to-Poly-X"><a href="#Convert-sequence-of-a-pose-to-Poly-X" class="headerlink" title="Convert sequence of a pose to Poly-X"></a>Convert sequence of a pose to Poly-X</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">polyA_chA = pyrosetta.rosetta.protocols.pose_creation.MakePolyXMover(aa=<span class="string">&quot;ALA&quot;</span>, keep_pro=<span class="number">0</span>, keep_gly=<span class="number">0</span>, keep_disulfide_cys=<span class="number">0</span>)</span><br><span class="line">polyA_chA.apply(pose)</span><br></pre></td></tr></table></figure>

<h2 id="Extract-a-region-a-chain-etc"><a href="#Extract-a-region-a-chain-etc" class="headerlink" title="Extract a region (a chain, etc.)"></a>Extract a region (a chain, etc.)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keep_chA = pyrosetta.rosetta.protocols.grafting.simple_movers.KeepRegionMover(res_start=<span class="built_in">str</span>(my_pose.chain_begin(<span class="number">1</span>)), res_end=<span class="built_in">str</span>(my_pose.chain_end(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<h2 id="Concatenate-2-poses-into-one-pose"><a href="#Concatenate-2-poses-into-one-pose" class="headerlink" title="Concatenate 2 poses into one pose"></a>Concatenate 2 poses into one pose</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyrosetta.rosetta.core.pose.append_pose_to_pose(pose1=pose_A, pose2=pose_BC, new_chain=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Vector1"><a href="#Vector1" class="headerlink" title="Vector1"></a>Vector1</h2><p> In PyRosetta, <code>Vector1</code> is a special object that acts like a Python list but is used to pass arguments to underlying C++ Rosetta functions. Rosetta’s C++ code uses a 1-based indexing convention, whereas Python lists use 0-based indexing. <code>Vector1</code> bridges this gap by creating a list-like object that is internally compatible with Rosetta’s C++ logic. </p>
<p><code>Vector1</code> is a convenience class that handles the necessary type conversion for you, so you can write a natural-looking list <code>[1]</code> in your Python code, and PyRosetta handles the rest.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyrosetta.rosetta.utility.Vector1([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="Setup-FoldTree"><a href="#Setup-FoldTree" class="headerlink" title="Setup FoldTree"></a>Setup FoldTree</h2><p><code>setup_foldtree</code> requires a <code>Vector1</code> object as input, not a standard Python list, because the underlying C++ code is expecting a <code>utility::vector1&lt;unsigned long&gt;</code> data type.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setup_foldtree(pose, <span class="string">&quot;A_B&quot;</span>, Vector1([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>protein design</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>biochemistry</tag>
        <tag>protein</tag>
        <tag>protein design</tag>
      </tags>
  </entry>
</search>
